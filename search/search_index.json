{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":"Mosheh  <p>Mosheh, automatic and elegant documentation of Python code with MkDocs.</p> <p>Inspirated by <code>cargodoc</code> - a Rust tool for code documenting - and using MkDocs + Material MkDocs, Mosheh is an easy, fast, plug-and-play tool which saves time while automating the process of documenting the source code of a Python codebase.</p> Project/Codebase PLoC Mosheh's Exec Time Mosheh ~4k 0.303s scikit-learn ~862k \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 11.783s NumPy ~204k \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 12.205 <p>PLoC: Python Lines of Code</p> <p>Specs: Mint 21.3 | Aspire A515-54 | Intel i7-10510U (8) @ 4.900GHz | RAM 19817MiB</p> <ul> <li>\ud83c\udfce Fast: Documented NumPy (200k+ Python LoC) in just 12.2 seconds</li> <li>\ud83d\ude42 Simple: No complex logic behind the scenes \u2014 easy to understand and trust</li> <li>\ud83d\udc4c Easy to Use: No advanced knowledge required \u2014 document any Python codebase effortlessly</li> <li>\ud83d\udd0c Plug and Play: No need to modify your codebase \u2014 just install Mosheh, <code>init</code>, configure <code>mosheh.json</code> and <code>create</code></li> <li>\ud83d\udcbc Professional: Generates MkDocs Material-based documentation \u2014 a clean, responsive, and professional website by default</li> <li>\ud83e\uddd1\u200d\ud83d\udcbb Modern: Designed for modern Python \u2014 fully type-hint-aware and built using the latest Python best practices</li> <li>\ud83d\udcc8 Scalable: Handles small scripts to massive codebases without performance issues</li> <li>\u27b0 Flexible: Works with any Python structure \u2014 does not enforce docstring formats or architectural patterns</li> <li>\ud83d\udd13 Open Source: Free to use, fully open-source under the MIT license, and built with community in mind</li> <li>\ud83d\udd17 Integrable: Easy to embed into CI/CD pipelines or project scaffolds for automatic documentation generation</li> </ul> <p></p> <p>This is not an alternative to MkDocs, but a complement based on it, since Mosheh lists all files you points to, saves every single notorious definition statement on each file iterated, all using Python <code>ast</code> native module for handling the AST and then generating a modern documentation respecting the dirs and files hierarchy.</p> <p>At the moment, Mosheh documents only Python files (<code>.py</code>, <code>.pyi</code>), where the stuff documented for each file is shown below:</p> <ul> <li> <p>Imports <code>ast.Import | ast.ImportFrom</code></p> </li> <li> <p> Type <code>Native | TrdParty | Local</code></p> </li> <li> Path (e.g. <code>math.sqrt</code>)</li> <li> <p> Code</p> </li> <li> <p>Constants <code>ast.Assign | ast.AnnAssign</code></p> </li> <li> <p> Name (token name)</p> </li> <li> Typing Annotation (datatype)</li> <li> Value (literal or call)</li> <li> <p> Code</p> </li> <li> <p>Classes <code>ast.ClassDef</code></p> </li> <li> <p> Description (docstring)</p> </li> <li> Name (class name)</li> <li> Parents (inheritance)</li> <li> Methods Defined (nums and names)</li> <li> <p> Code</p> </li> <li> <p>Funcs <code>ast.FunctionDef | ast.AsyncFunctionDef</code></p> </li> <li> <p> Description (docstring)</p> </li> <li> Name (func name)</li> <li> Type <code>Func | Method | Generator | Coroutine</code></li> <li> Parameters (name, type, default)</li> <li> Return Type (datatype)</li> <li> Raises (exception throw)</li> <li> <p> Code</p> </li> <li> <p>Assertions <code>ast.Assert</code></p> </li> <li> <p> Test (assertion by itself)</p> </li> <li> Message (opt. message in fail case)</li> <li> Code</li> </ul>"},{"location":"#stack","title":"Stack","text":""},{"location":"#contributing","title":"Contributing","text":"<p>Before getting access to the To-Do List, Coding Style or even forking the project, we strongly recommend reading Mosheh's Guidelines</p>"},{"location":"#arch","title":"Arch","text":"<p>Mosheh's architecture can be interpreted in two ways: the directory structure and the interaction of the elements that make it up. A considerable part of a project is - or at least should be - that elements that are dispensable for its functionality are in fact dispensable, such as the existence of automated tests; they are important so that any existing quality process is kept to a minimum acceptable level, but if all the tests are deleted, the tool still works.</p> <p>Here it is no different, a considerable part of Mosheh is, in fact, completely dispensable; follow below the structure of directories and relevant files that are part of this project:</p> Bash<pre><code>.\n\u251c\u2500\u2500 mosheh/                     # Mosheh's source-code\n\u2502   \u251c\u2500\u2500 commands/*              # Logics for each command\n\u2502   \u251c\u2500\u2500 handlers/*              # Codebase handlers for each file\n\u2502   \u251c\u2500\u2500 doc/*                   # Documentation build logics\n\u2502   \u251c\u2500\u2500 types/                  # Custom data types\n\u2502   \u2502   \u251c\u2500\u2500 basic.py            # Basic types (e.g. \"type Token = str\")\n\u2502   \u2502   \u251c\u2500\u2500 contracts.py        # Contracts to ensure correct typing\n\u2502   \u2502   \u251c\u2500\u2500 enums.py            # Enums for standardizing assignments\n\u2502   \u2502   \u2514\u2500\u2500 jsoncfg.py          # JSON for structuring commands config\n\u2502   \u251c\u2500\u2500 codebase.py             # Codebase reading logic\n\u2502   \u251c\u2500\u2500 constants.py            # Constants to be evaluated\n\u2502   \u251c\u2500\u2500 main.py                 # Entrypoint\n\u2502   \u2514\u2500\u2500 utils.py                # Utilities\n\u2502\n\u251c\u2500\u2500 tests/                      # Template dir for testing\n\u2502   \u251c\u2500\u2500 DOC                     # Doc output dir\n\u2502   \u251c\u2500\u2500 PROJECT                 # Template project dir\n\u2502   \u2514\u2500\u2500 unittest                # Automated tests\n\u2502\n\u251c\u2500\u2500 documentation/              # Mosheh's documentation dir\n\u2502   \u251c\u2500\u2500 docs/                   # Dir containing .md files and assets\n\u2502   \u251c\u2500\u2500 mkdocs.yml              # MkDocs's config file\n\u2502   \u2514\u2500\u2500 mosheh.json             # Mosheh's exec config file\n\u2502\n\u251c\u2500\u2500 pyproject.toml              # Mosheh's config file for almost everything\n\u251c\u2500\u2500 uv.lock                     # uv's lockfile for dealing with dependencies\n\u251c\u2500\u2500 .python-version             # Default Python's version to use\n\u2502\n\u251c\u2500\u2500 .github/                    # Workflows and social stuff\n\u2502\n\u251c\u2500\u2500 LICENSE                     # Legal stuff, A.K.A donut sue me\n\u2502\n\u2514\u2500\u2500 .gitignore                  # Git \"exclude\" file\n</code></pre> <p>It is to be expected that if the <code>tests/</code> directory is deleted, Mosheh's core will not be altered in any way, so much so that when a tool is downloaded via <code>pip</code> or similar, the tool is not accompanied by tests, licenses, development configuration files or workflows. So, to help you understand how the <code>mosheh/</code> directory works, here's how the functional elements interact with each other:</p> <p></p>"},{"location":"#usage","title":"Usage","text":"<p>After installing Mosheh as a development dependency, create the documentation folder if not exists and run <code>mosheh init [--path .]</code>; this will result in a <code>mosheh.json</code> config file just as below:</p> JSON<pre><code>{\n  \"documentation\": {\n    \"projectName\": \"Mosheh\",\n    \"repoName\": \"mosheh\",\n    \"repoUrl\": \"https://github.com/lucasgoncsilva/mosheh\",\n    \"editUri\": \"blob/main/documentation/docs\",\n    \"siteUrl\": \"https://lucasgoncsilva.github.io/mosheh/\",\n    \"logoPath\": \"./path/to/logo.svg\",\n    \"readmePath\": \"./path/to/README.md\",\n    \"codebaseNavPath\": \"Codebase\"\n  },\n  \"io\": {\n    \"rootDir\": \"./app/\",\n    \"outputDir\": \"./path/to/output/\"\n  }\n}\n</code></pre> <p>After making sure the data on that JSON reflects the desired (more about this file at the official documentation), running <code>mosheh create [--json .]</code> results in a documentation following the default MkDocs structure with Material MkDocs as theme, with the codebase documented over \"Codebase\" named-section.</p>"},{"location":"#development","title":"Development","text":""},{"location":"#installing-dependencies","title":"Installing Dependencies","text":"Bash<pre><code># Automatically handles everything with .venv\nuv sync\n</code></pre>"},{"location":"#running-locally","title":"Running Locally","text":"Bash<pre><code># For running using uv and dealing with Mosheh as a module\nuv run mosheh -h\n</code></pre>"},{"location":"#building-locally","title":"Building Locally","text":"Bash<pre><code># Build pip-like file\nuv build\n</code></pre>"},{"location":"#testing","title":"Testing","text":"Bash<pre><code># Run all the testing workflow\nuv run task test\n</code></pre>"},{"location":"#lint","title":"Lint","text":"Bash<pre><code># Run all the linting workflow\nuv run task lint\n</code></pre>"},{"location":"#generate-self-document","title":"Generate Self Document","text":"Bash<pre><code># Generate Mosheh's Codebase Documentation\nuv run task makedoc\n</code></pre>"},{"location":"#benchmarking","title":"Benchmarking","text":"Bash<pre><code># Running benchmark with Memray and Scalene\nuv run task benchmark\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is under MIT License. A short and simple permissive license with conditions only requiring preservation of copyright and license notices. Licensed works, modifications, and larger works may be distributed under different terms and without source code.</p>"},{"location":"changelog/","title":"Changelog and Update History","text":"<p>A changelog is a document that tracks the history of changes in a project, typically organized by version numbers. It serves as a transparent record for developers, users, and contributors, detailing what has been added, updated, fixed, removed, or addressed in terms of security. By offering a structured overview, changelogs play a vital role in maintaining trust, facilitating communication, and easing version management.</p> <p>Changelogs provide a transparent narrative of a project\u2019s evolution. They ensure users can make informed decisions about updating software and give contributors insights into the project\u2019s direction. For development teams, changelogs are invaluable for version control and accountability. Well-maintained changelogs foster trust, improve user engagement, and ensure smoother project management for all stakeholders.</p> <p>Key Components of a Changelog:</p> <ul> <li>Adds: This section highlights new features, tools, or functionalities introduced to the project. For example, a CLI tool may include a new command or configuration option. Clearly listing these additions allows users to discover improvements and expanded capabilities.</li> <li>Updates: Updates reflect modifications or enhancements to existing features, such as performance optimizations or UI/UX improvements. These entries help users understand what has evolved, ensuring they benefit from improved usability or efficiency.</li> <li>Fixes: Fixes document the resolution of bugs or issues. By specifying what was corrected, users gain confidence that problems they may have encountered have been addressed, reducing frustration.</li> <li>Deprecates: When something (function, approach or even feature) is replaced but still available, usually for retrocompatibility, this thing is marked as deprecated; the idea is to remove later without breaking existing use cases.</li> <li>Removes: Sometimes, features or functionalities are removed. Listing these changes prevents surprises, enabling users to adapt and refactor their workflows accordingly.</li> <li>Security: Security changes focus on vulnerabilities that have been mitigated or resolved. This section reassures users that the project maintains high standards for safety and data protection.</li> </ul>"},{"location":"changelog/#v204-2025-08-20","title":"v2.0.4 - 2025-08-20","text":""},{"location":"changelog/#adds","title":"Adds","text":"<ul> <li>Internal development command for benchmarking with Memray and Scalene</li> </ul>"},{"location":"changelog/#updates","title":"Updates","text":"<ul> <li><code>tests.PROJECT</code> replaced to a real project's codebase</li> </ul>"},{"location":"changelog/#v203-2025-08-11","title":"v2.0.3 - 2025-08-11","text":""},{"location":"changelog/#fixes","title":"Fixes","text":"<ul> <li>Mypy report for <code>mosheh.handlers.python</code> after PR 13</li> </ul>"},{"location":"changelog/#v202-2025-08-06","title":"v2.0.2 - 2025-08-06","text":""},{"location":"changelog/#adds_1","title":"Adds","text":"<ul> <li>Features list to <code>README.md</code></li> </ul>"},{"location":"changelog/#updates_1","title":"Updates","text":"<ul> <li>Refactor <code>_handle_node</code> for improved performance and readability by using <code>ast.unparse</code> directly - PR 13 - @MananJain39</li> <li>Moved homepage logic to <code>mosheh.doc.shared</code></li> <li>Test suite updates with Hypothesis</li> </ul>"},{"location":"changelog/#fixes_1","title":"Fixes","text":"<ul> <li>Small documentation issues, such as Discussion Templates titles</li> </ul>"},{"location":"changelog/#removes","title":"Removes","text":"<ul> <li>Remove unused <code>_handle_general</code> function after refactoring - PR 13 - @MananJain39</li> <li>Remove unnecessary <code>typing.cast</code> calls - PR 13 - @MananJain39</li> </ul>"},{"location":"changelog/#v201-2025-07-30","title":"v2.0.1 - 2025-07-30","text":""},{"location":"changelog/#adds_2","title":"Adds","text":"<ul> <li><code>.github/DISCUSSION_TEMPLATE</code> files for discussion templates: \"Questions\", \"Showcases\" and \"Ideas to Features\"</li> </ul>"},{"location":"changelog/#updates_2","title":"Updates","text":"<ul> <li>Replaced manual binary search implementation with <code>bisect.bisect_left</code> wrapper in <code>utils.bin</code> - PR 7 - @ClanEver</li> <li>Refactored dataclass implementations to use NamedTuple - PR 6 - @ClanEver</li> <li>Updated method calls from <code>.as_dict</code> to <code>._asdict()</code> - PR 6 - @ClanEver</li> </ul>"},{"location":"changelog/#fixes_2","title":"Fixes","text":"<ul> <li><code>README.md</code> gif of Mosheh use</li> </ul>"},{"location":"changelog/#v200-2025-07-24","title":"v2.0.0 - 2025-07-24","text":""},{"location":"changelog/#adds_3","title":"Adds","text":"<ul> <li>Social <code>.github</code> files such as templates and guidelines (<code>ISSUE_TEMPLATE/</code>, <code>TODO.md</code>, ...)</li> <li><code>py.typed</code> for defining Mosheh as a typed project</li> <li>New command <code>mosheh update --json .</code> for updating an existing codebase documentation</li> </ul>"},{"location":"changelog/#updates_3","title":"Updates","text":"<ul> <li>CLI interface from simple commands to new logic with <code>init</code>, <code>create</code> and <code>mosheh.json</code></li> <li><code>README.md</code> and other documentation properly updated</li> <li><code>mosheh.custom_types</code> divided into <code>mosheh.types</code> with <code>basic</code>, <code>contracts</code>, <code>jsoncfg</code> and <code>enums</code></li> <li>Enums inheritance change from <code>enum.Enum</code> to <code>enum.StrEnum</code></li> <li><code>mosheh.types.basic</code> definition using <code>type</code> keyword</li> <li><code>handler.py</code> moved to <code>/handlers/python.py</code> for future convenience</li> <li><code>mosheh.handlers.python.handle_def_nodes</code> renamed to <code>handle_std_nodes</code></li> <li><code>mosheh.handlers.python._handle_general</code> for dealing with <code>ast.AST</code> not defined on <code>types.contracts</code></li> <li><code>commands/*</code> to deal with different commands instead of <code>main.py</code> raw logic</li> <li>General docstring for new and updated files/functions/classes</li> </ul>"},{"location":"changelog/#fixes_3","title":"Fixes","text":"<ul> <li>Rename variables with duplicated names</li> <li>File path with <code>.dir</code> managed to <code>dir</code></li> <li>\"Notation\" into \"Annotation\" writing over codebase</li> </ul>"},{"location":"changelog/#removes_1","title":"Removes","text":"<ul> <li><code>mosheh.handler</code> internal funcs but the ones called by <code>mosheh.handler.handle_std_nodes</code></li> </ul>"},{"location":"changelog/#v134-2025-01-07","title":"v1.3.4 - 2025-01-07","text":""},{"location":"changelog/#adds_4","title":"Adds","text":"<ul> <li>File docstrings for source code, documenting the file role</li> <li>File docstrings now observed and inserted into output documentation markdown</li> </ul>"},{"location":"changelog/#updates_4","title":"Updates","text":"<ul> <li>Mosheh now requires Python 3.13</li> <li>Dependencies now supports versions in <code>lib&gt;=x.x.x</code> style, no more <code>lib==x.x.x</code> only</li> <li><code>mosheh.doc</code> functions <code>__write_to_file</code> to <code>_write_to_file</code> and <code>__update_navigation</code> to <code>_update_navigation</code></li> </ul>"},{"location":"changelog/#fixes_4","title":"Fixes","text":"<ul> <li><code>'.'</code> added to generated documentation files and dirs on <code>mosheh.doc</code> creation lines</li> </ul>"},{"location":"changelog/#v133-2024-12-27","title":"v1.3.3 - 2024-12-27","text":""},{"location":"changelog/#adds_5","title":"Adds","text":"<ul> <li>\"Role\" defined and added to markdown generated doc files</li> <li>Functions now has docstring description on markdown</li> </ul>"},{"location":"changelog/#updates_5","title":"Updates","text":"<ul> <li>Codebase readed files now documented under <code>- Codebase</code> section on generated <code>mkdocs.yml</code></li> </ul>"},{"location":"changelog/#security","title":"Security","text":"<ul> <li><code>f'{name}'</code> to <code>f'{name}'</code> on <code>tests.PROJECT.dummy.views.index</code> test example</li> </ul>"},{"location":"changelog/#v132-2024-12-17","title":"v1.3.2 - 2024-12-17","text":""},{"location":"changelog/#adds_6","title":"Adds","text":"<ul> <li><code>_mark_methods</code> created on <code>mosheh.codebase</code> plus <code>encapsulated_mark_methods_for_unittest</code> for testing</li> <li>Examples for <code>mosheh.handler</code> functions on docstrings</li> </ul>"},{"location":"changelog/#updates_6","title":"Updates","text":"<ul> <li>Sequence-like <code>mosheh.constants</code> constants sorted in code to better performing</li> </ul>"},{"location":"changelog/#fixes_5","title":"Fixes","text":"<ul> <li>Implementing <code>rich</code> as direct dependency</li> </ul>"},{"location":"changelog/#v131-2024-12-16","title":"v1.3.1 - 2024-12-16","text":""},{"location":"changelog/#adds_7","title":"Adds","text":"<ul> <li>Publish official documentation website: https://lucasgoncsilva.github.io/mosheh/</li> </ul>"},{"location":"changelog/#updates_7","title":"Updates","text":"<ul> <li>Remaking the Mosheh's documentation itself</li> <li>Setting documentation website metadata on <code>pyproject.toml</code></li> <li><code>mosheh.constants</code> constants <code>BUILTIN_MODULES</code>, <code>BUILTIN_FUNCTIONS</code>, <code>BUILTIN_DUNDER_METHODS</code> and <code>ACCEPTABLE_LOWER_CONSTANTS</code> from <code>typing.Iterator</code> to <code>typing.Sequence</code></li> </ul>"},{"location":"changelog/#v130-2024-12-13","title":"v1.3.0 - 2024-12-13","text":""},{"location":"changelog/#adds_8","title":"Adds","text":"<ul> <li>Handler functions to deal with statements not defined before, such as <code>ast.For</code> - all below:</li> </ul> Added Nodes <code>ast.AsyncFor</code> <code>ast.AsyncWith</code> <code>ast.AugAssign</code> <code>ast.Await</code> <code>ast.Break</code> <code>ast.Continue</code> <code>ast.Del</code> <code>ast.Delete</code> <code>ast.ExceptHandler</code> <code>ast.Expr</code> <code>ast.For</code> <code>ast.FormattedValue</code> <code>ast.Global</code> <code>ast.If</code> <code>ast.Load</code> <code>ast.Match</code> <code>ast.NamedExpr</code> <code>ast.Nonlocal</code> <code>ast.ParamSpec</code> <code>ast.Pass</code> <code>ast.Raise</code> <code>ast.Return</code> <code>ast.Starred</code> <code>ast.Store</code> <code>ast.TryStar</code> <code>ast.Try</code> <code>ast.TypeAlias</code> <code>ast.TypeVarTuple</code> <code>ast.TypeVar</code> <code>ast.While</code> <code>ast.With</code> <code>ast.YieldFrom</code> <code>ast.Yield</code> <ul> <li><code>rtype</code> or return type annotation on <code>tests.unittest</code> test functions</li> <li>New theme to Mosheh's self documentation code blocks inspired by Dracula Theme</li> <li>Insert logs on all the Mosheh's codebase using <code>mosheh.set_logging_config</code> and native <code>logging</code>:</li> <li>CRITICAL: when something crashes the script</li> <li>ERROR: non-crashing errors on the script</li> <li>WARNING: notorious advising that are not errors</li> <li>INFO: normal log level</li> <li>DEBUG: detailed step-by-step execution</li> </ul>"},{"location":"changelog/#updates_8","title":"Updates","text":"<ul> <li><code>mosheh.handler._handle_node</code> now can handle nodes off all types listed above</li> <li><code>ast.FunctionDef</code> inside of <code>ast.ClassDef</code> now with <code>FunctionType.Method</code> attribute on output doc</li> </ul>"},{"location":"changelog/#removes_2","title":"Removes","text":"<ul> <li><code>Statement</code> class from <code>mosheh.custom_types</code> unused types, such as <code>Statement.Call</code> - all below:</li> </ul> Removed Types <code>BinOp = auto()</code> <code>Call = auto()</code> <code>Compare = auto()</code> <code>List = auto()</code> <code>Set = auto()</code> <code>Tuple = auto()</code> <code>Dict = auto()</code> <code>Slice = auto()</code> <code>Subscript = auto()</code>"},{"location":"changelog/#v121-2024-12-10","title":"v1.2.1 - 2024-12-10","text":""},{"location":"changelog/#adds_9","title":"Adds","text":"<ul> <li>Unittest workflow for automated tests using <code>pytest</code>: <code>.github/workflows/unittest.yml</code></li> <li>PyPI publishing workflow for new public versions using <code>uv</code> and <code>twine</code>: <code>.github/workflows/publish_pypi.yml</code></li> <li>MkDocs publishing workflow for updating documentation using <code>uv</code> and <code>mkdocs</code>: <code>.github/workflows/publish_mkdocs.yml</code></li> <li>New badges for <code>README.md</code> \"Stack\" section: Material for MkDocs, GitHub, GitHub Pages and GitHub Actions</li> <li><code>[build-system]</code>, <code>[project.urls]</code>, <code>[project.scripts]</code> and some other small infos inserted on <code>pyproject.toml</code></li> </ul>"},{"location":"changelog/#updates_9","title":"Updates","text":"<ul> <li>Reordering Stack badges for <code>README.md</code></li> </ul>"},{"location":"changelog/#fixes_6","title":"Fixes","text":"<ul> <li><code>mosheh</code> back as script entrypoint for Mosheh in <code>pyproject.toml</code> config file</li> </ul>"},{"location":"changelog/#removes_3","title":"Removes","text":"<ul> <li><code>setup.py</code> deleted due total substitution by <code>pyproject.toml</code></li> </ul>"},{"location":"changelog/#v120-2024-12-10","title":"v1.2.0 - 2024-12-10","text":""},{"location":"changelog/#adds_10","title":"Adds","text":"<ul> <li>Test file for <code>mosheh.utils</code> functions: <code>tests.unittest.utils</code></li> <li>Test file for <code>mosheh.constants</code> constants: <code>tests.unittest.constants</code></li> <li>Test file for <code>mosheh.doc</code> functions: <code>tests.unittest.doc</code></li> <li>Test file for <code>mosheh.handler</code> functions: <code>tests.unittest.handler</code></li> <li>Mock test file <code>mock.py.txt</code> for serving <code>tests.unittest.handler</code> as template</li> </ul>"},{"location":"changelog/#updates_10","title":"Updates","text":"<ul> <li><code>pyproject.toml</code> setting <code>pytest</code> to use <code>-vv</code> parameter</li> <li><code>list[Any] | tuple[Any]</code> to <code>collections.abc.Sequence[Any]</code> on <code>mosheh.utils.bin:universe</code> arg</li> <li><code>dict[Any, Any]</code> to <code>defaultdict[Any, Any]</code> on <code>mosheh.utils.nested_dict</code> rtype</li> <li><code>dict[Any, Any]</code> to <code>defaultdict[Any, Any]</code> on <code>mosheh.utils.add_to_dict:structure</code> arg and rtype</li> <li>Changing all <code>moshe.doc</code> functions except <code>create_doc</code> to be private (e.g. <code>_process_file</code>)</li> <li>Changing all <code>moshe.handlers</code> functions except <code>handle_std_nodes</code> to be private (e.g. <code>_process_file</code>)</li> <li>Renaming <code>moshe.handlers</code> to <code>moshe.handler</code></li> <li>Changing <code>moshe.codebase.iterate</code> to be private: <code>moshe.codebase._iterate</code></li> </ul>"},{"location":"changelog/#fixes_7","title":"Fixes","text":"<ul> <li><code>Proccess</code> word refined to <code>Process</code></li> </ul>"},{"location":"changelog/#v111-2024-12-06","title":"v1.1.1 - 2024-12-06","text":""},{"location":"changelog/#adds_11","title":"Adds","text":"<ul> <li><code>metadata.py</code> created to separate metadata from the actual <code>main.py</code> file</li> </ul>"},{"location":"changelog/#updates_11","title":"Updates","text":"<ul> <li>Migration from <code>pip</code>/<code>requirements.txt</code> dependency management to <code>uv</code>/<code>pyproject.toml</code>/<code>uv.lock</code>/<code>.python-version</code></li> <li><code>documentation/*.md</code> files formatted</li> <li><code>README.md</code> updated with new local installation and running instructions</li> <li><code>README.md</code> updated with new dependency management system into dir's demonstration</li> <li>Substituting <code>handlers.py</code>'s <code>typing.Optional</code> to <code>... | None</code> (e.g. <code>Optional[str]</code> to <code>str | None</code>)</li> </ul>"},{"location":"changelog/#removes_4","title":"Removes","text":"<ul> <li><code>ruff.toml</code> deleted due to <code>pyproject.toml</code> creation</li> </ul>"},{"location":"changelog/#v110-2024-12-06","title":"v1.1.0 - 2024-12-06","text":""},{"location":"changelog/#adds_12","title":"Adds","text":"<ul> <li>Creation of <code>CHANGELOG.md</code></li> <li><code>setup.py</code> into <code>README.md</code> dir's demonstration</li> <li><code>documentation</code> into <code>README.md</code> dir's demonstration</li> <li><code>--edit-uri</code> parameter defined as <code>'blob/main/documentation/docs'</code></li> </ul>"},{"location":"changelog/#updates_12","title":"Updates","text":"<ul> <li><code>README.md</code>'s todo list targets</li> <li><code>--exit</code> parameter renamed to <code>--output</code></li> <li><code>--logo-path</code> argument's defaults to <code>None</code></li> <li><code>--readme-path</code> argument's defaults to <code>None</code></li> <li><code>clickable_checkbox</code> statement of <code>mkdocs.yml</code> defaults to <code>false</code></li> <li>Some function docstrings reviewed</li> </ul>"},{"location":"changelog/#v100-2024-12-04","title":"v1.0.0 - 2024-12-04","text":""},{"location":"changelog/#adds_13","title":"Adds","text":"<ul> <li>First stable version release</li> </ul>"},{"location":"starting/","title":"Getting Starded","text":"<p>The Homepage already introduced Mosheh's usage in a nutshell and just by readind there you are already able to use it, but here we are going to cover it in details.</p>"},{"location":"starting/#installation","title":"Installation","text":"<p>To install Mosheh there is no secret, you can literally just tell your package manager to install <code>mosheh</code> and use it. As it has no production-like role, it's highly recommended to install as dev dependency, also saving as it as well.</p>"},{"location":"starting/#uv","title":"uv","text":"<p>An extremely fast Python package and project manager, uv is written in Rust and backed by Astral, the creators of Ruff. In a few words, uv has an ambitious proposal: use the power of Rust to replace <code>pip</code>, <code>pip-tools</code>, <code>pipx</code>, <code>poetry</code>, <code>pyenv</code>, <code>twine</code>, <code>virtualenv</code> and more dev tools like these. To install Mosheh with uv just use the command below:</p> Bash<pre><code>uv add mosheh --dev\n</code></pre> <p>By doing it, uv is going to save Mosheh as dev dependency on <code>pyproject.toml</code> with the structure below, where <code>x.x.x</code> is the last version released or the chosen one:</p> YAML<pre><code>[project]\nname = \"your-project\"\n...\n\n[dependency-groups]\ndev = [\"mosheh&gt;=x.x.x\"]\n</code></pre> <p>For more information about uv installation please check: https://docs.astral.sh/uv/</p> <p>Personal Recomendation</p> <p>uv is the personal recomendation for managing project dependencies and handling development tasks, such as building; check it out for your personal use case.</p>"},{"location":"starting/#pip","title":"PIP","text":"<p>The most commonly used tool for dependency management, PIP is frequently installed with the Python Interpreter. It has no command or parameter to install libs as development dependency, but there is a recommended solution to this: separate a production requirements file from a development one. To achieve this goal follow the steps below:</p> <ol> <li>Create a <code>requirements.dev.txt</code> or similar: <code>touch requirements.dev.txt</code></li> <li>Tell it to read main/production <code>requirements.txt</code>: <code>echo \"-r ./path/to/requirements.txt\" &gt; requirements.dev.txt</code></li> <li>Install Mosheh with common install command: <code>pip install mosheh</code></li> <li>Write Mosheh to the dev requirements file: <code>echo mosheh &gt;&gt; requirements.dev.txt</code></li> </ol> <p>The full logic ends like this:</p> Bash<pre><code>touch requirements.dev.txt\necho \"-r ./path/to/requirements.txt\" &gt; requirements.dev.txt\npip install mosheh\necho mosheh &gt;&gt; requirements.dev.txt\n</code></pre> <p>Example Path Above</p> <p>Just remember to update path to the real path on your case, just copying and pasting may not work because the used path is a mock one.</p>"},{"location":"starting/#poetry","title":"Poetry","text":"<p>Poetry is a tool for dependency management and packaging in Python. It allows you to declare the libraries your project depends on and it will manage (install/update) them for you. Poetry offers a lockfile to ensure repeatable installs, and can build your project for distribution. Just like uv, Poetry is better than PIP because of its robust features list, ensuring more possibilities to automate and handle development processes. To install Mosheh with Poetry you can run the command below:</p> Bash<pre><code>poetry add mosheh -G dev\n</code></pre> <p>Since <code>--dev</code> is now deprecated the documentation itself says to use <code>--group dev</code> <code>-G dev</code>. Being more specific you can also define Mosheh as documentation dependency, depending on how you wants to deal with it by running <code>poetry add mosheh -G docs</code>.</p>"},{"location":"starting/#execution","title":"Execution","text":"<p>As shown above, there are different ways to install Mosheh and the same happens when running it. In general cases calling <code>mosheh</code> on terminal already works, but depending on the installation method there are better options to execute the same script.</p> <p>If using PIP, the way demonstraded below is suficient:</p> Bash<pre><code>mosheh [-h] [--verbose {0,1,2,3,4}] {init,run} ...\n</code></pre> <p>Elif using uv, call <code>mosheh</code> from <code>uv run</code> to be concise with the ecosystem in use:</p> Bash<pre><code>uv run mosheh [-h] [--verbose {0,1,2,3,4}] {init,create} ...\n</code></pre>"},{"location":"starting/#commands","title":"Commands","text":""},{"location":"starting/#global-parameter","title":"Global Parameter","text":"<p>Apart from command-specific parameters, there\u2019s also one global parameter that can (and should) be used to control output verbosity.</p>"},{"location":"starting/#-verbose","title":"<code>--verbose</code>","text":"<ul> <li>Mandatory: <code>Optional</code></li> <li>Type: <code>int</code></li> <li>Default: <code>3</code></li> </ul> <p>Controls the verbosity level of the CLI output, ranging from <code>0</code> to <code>4</code>:</p> <ul> <li><code>0</code>: Quiet / Critical only</li> <li><code>1</code>: Errors</li> <li><code>2</code>: Warnings</li> <li><code>3</code>: Default info level</li> <li><code>4</code>: Full debug / oversharing</li> </ul> <p>Use this flag depending on your context \u2014 whether you need clean output or full transparency for debugging and tracking.</p> <p>Mosheh currently supports two main commands that represent its usage modes: <code>init</code> and <code>create</code>. Each has its own parameters, and there\u2019s also a global one available across executions: <code>--verbose</code>.</p>"},{"location":"starting/#init","title":"<code>init</code>","text":"<p>Initializes Mosheh by creating the configuration file that enables its usage. Nothing can be done without this config file with the name of <code>mosheh.json</code></p>"},{"location":"starting/#-path","title":"<code>--path</code>","text":"<ul> <li>Mandatory: <code>Optional</code></li> <li>Type: <code>str</code></li> <li>Default: <code>'.'</code></li> </ul> <p>Defines where the configuration file should be created. If nothing is informed, it defaults to the current directory (<code>.</code>). This allows flexibility to scaffold the config at any desired location inside the project. The config file generated is detailed below:</p> JSON<pre><code>{\n  \"documentation\": {\n    \"projectName\": \"Mosheh\",\n    \"repoName\": \"mosheh\",\n    \"repoUrl\": \"https://github.com/lucasgoncsilva/mosheh\",\n    \"editUri\": \"blob/main/documentation/docs\",\n    \"siteUrl\": \"https://lucasgoncsilva.github.io/mosheh/\",\n    \"logoPath\": \"./path/to/logo.svg\",\n    \"readmePath\": \"./path/to/README.md\",\n    \"codebaseNavPath\": \"Codebase\"\n  },\n  \"io\": {\n    \"rootDir\": \"./app/\",\n    \"outputDir\": \"./path/to/output/\"\n  }\n}\n</code></pre>"},{"location":"starting/#section-documentation","title":"Section <code>\"documentation\"</code>","text":"<p>Documentation-related data</p> <ul> <li><code>\"projectName\"</code>: Name of the project (e.g. \"Mosheh\")</li> <li><code>\"repoName\"</code>: Name of the repository (e.g. \"django-ninja\")</li> <li><code>\"repoUrl\"</code>: URL of the repository (e.g. \"https://github.com/matplotlib/matplotlib\")</li> <li><code>\"editUri\"</code>: Editting URI (e.g. \"blob/main/documentation/docs\")</li> <li><code>\"siteUrl\"</code>: URL of the documentation website (path included if necessary)</li> <li><code>\"logoPath\"</code>: Relative path of the project's logo (inside repository)</li> <li><code>\"readmePath\"</code>: Relative path of the project's README (inside repository)</li> <li><code>\"codebaseNavPath\"</code>: Documentation path to the codebase section</li> </ul>"},{"location":"starting/#section-io","title":"Section <code>\"io\"</code>","text":"<p>IO-related data</p> <ul> <li><code>\"rootDir\"</code>: Relative path for the codebase dir</li> <li><code>\"outputDir\"</code>: Relative path for the documentation output dir</li> </ul>"},{"location":"starting/#create","title":"<code>create</code>","text":"<p>Mosheh's feature for codebase tracking and documentation creation. It runs the tool based on the configuration and setup defined. By reading the config file, evaluates the pointed codebase, registers it's data and generates the output file markdown for each file, writing every file to a path respecting the codebase path.</p>"},{"location":"starting/#-json","title":"<code>--json</code>","text":"<ul> <li>Mandatory: <code>Optional</code></li> <li>Type: <code>str</code></li> <li>Default: <code>'.'</code></li> </ul> <p>Defines where to read the configuration file from. If not provided, it will assume the current directory. This parameter enables control over which config Mosheh should consider when running.</p>"},{"location":"starting/#update","title":"<code>update</code>","text":"<p>Mosheh's feature for codebase tracking and documentation updating. It runs the tool based on the configuration and setup defined. Executes almost the same logic of <code>create</code> command, but just updating the codebase markdown files instead of creating the documentation from scratch.</p>"},{"location":"starting/#-json_1","title":"<code>--json</code>","text":"<ul> <li>Mandatory: <code>Optional</code></li> <li>Type: <code>str</code></li> <li>Default: <code>'.'</code></li> </ul> <p>Defines where to read the configuration file from. If not provided, it will assume the current directory. This parameter enables control over which config Mosheh should consider when running.</p>"},{"location":"Codebase/mosheh/__init__.py/","title":"File: <code>__init__.py</code>","text":"<p>Role:  Python Source Code</p> <p>Path: <code>mosheh</code></p> <p>No file docstring provided.</p>"},{"location":"Codebase/mosheh/__init__.py/#imports","title":"Imports","text":"<p>NO IMPORT DEFINED HERE</p>"},{"location":"Codebase/mosheh/__init__.py/#consts","title":"Consts","text":"<p>NO CONSTANT DEFINED HERE</p>"},{"location":"Codebase/mosheh/__init__.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"Codebase/mosheh/__init__.py/#functions","title":"Functions","text":"<p>NO FUNCTION DEFINED HERE</p>"},{"location":"Codebase/mosheh/__init__.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"Codebase/mosheh/codebase.py/","title":"File: <code>codebase.py</code>","text":"<p>Role:  Python Source Code</p> <p>Path: <code>mosheh</code></p> <p>This module provides functionality to analyze a Python codebase extracting and organizing its structural information.</p> <p>The primary purpose of this module is to traverse a directory tree, identify Python source files, and parse their abstract syntax trees (AST) to collect metadata about their classes, functions, and methods. The gathered data is organized in a nested dictionary format (<code>CodebaseDict</code>) to facilitate further processing and analysis.</p> <p>Key Functions:</p> <ul> <li> <p><code>read_codebase</code>: Orchestrates the entire process by iterating through the codebase,     parsing Python files, and storing structured information about their contents.</p> </li> <li> <p><code>_iterate</code>: Recursively yields file paths within the provided root directory for     iteration.</p> </li> </ul> <p>How It Works:</p> <ol> <li> <p>The <code>read_codebase</code> function starts by invoking <code>_iterate</code> to navigate into the     directory tree starting from the given root path.</p> </li> <li> <p>For each file encountered, if a valid, expected extension, the file is read and its     AST or content - if not a programming language file - is parsed to extract relevant     information.</p> </li> <li> <p>The result is a comprehensive dictionary (<code>CodebaseDict</code>) containing all collected     data, which is returned as a standard dictionary for compatibility.</p> </li> </ol> <p>This module is a foundational component for automated documentation generation, providing the structural insights needed for subsequent steps in the documentation pipeline.</p>"},{"location":"Codebase/mosheh/codebase.py/#imports","title":"Imports","text":""},{"location":"Codebase/mosheh/codebase.py/#import-defaultdict","title":"<code>import defaultdict</code>","text":"<p>Path: <code>collections</code></p> <p>Category: native</p> Snippet Python<pre><code>from collections import defaultdict\n</code></pre>"},{"location":"Codebase/mosheh/codebase.py/#import-generator","title":"<code>import Generator</code>","text":"<p>Path: <code>collections.abc</code></p> <p>Category: native</p> Snippet Python<pre><code>from collections.abc import Generator\n</code></pre>"},{"location":"Codebase/mosheh/codebase.py/#import-logger","title":"<code>import Logger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import Logger\n</code></pre>"},{"location":"Codebase/mosheh/codebase.py/#import-getlogger","title":"<code>import getLogger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import getLogger\n</code></pre>"},{"location":"Codebase/mosheh/codebase.py/#import-path","title":"<code>import path</code>","text":"<p>Path: <code>os</code></p> <p>Category: native</p> Snippet Python<pre><code>from os import path\n</code></pre>"},{"location":"Codebase/mosheh/codebase.py/#import-walk","title":"<code>import walk</code>","text":"<p>Path: <code>os</code></p> <p>Category: native</p> Snippet Python<pre><code>from os import walk\n</code></pre>"},{"location":"Codebase/mosheh/codebase.py/#import-any","title":"<code>import Any</code>","text":"<p>Path: <code>typing</code></p> <p>Category: native</p> Snippet Python<pre><code>from typing import Any\n</code></pre>"},{"location":"Codebase/mosheh/codebase.py/#import-handle_python_file","title":"<code>import handle_python_file</code>","text":"<p>Path: <code>mosheh.handlers</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.handlers import handle_python_file\n</code></pre>"},{"location":"Codebase/mosheh/codebase.py/#import-codebasedict","title":"<code>import CodebaseDict</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import CodebaseDict\n</code></pre>"},{"location":"Codebase/mosheh/codebase.py/#import-convert_to_regular_dict","title":"<code>import convert_to_regular_dict</code>","text":"<p>Path: <code>mosheh.utils</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.utils import convert_to_regular_dict\n</code></pre>"},{"location":"Codebase/mosheh/codebase.py/#import-nested_defaultdict","title":"<code>import nested_defaultdict</code>","text":"<p>Path: <code>mosheh.utils</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.utils import nested_defaultdict\n</code></pre>"},{"location":"Codebase/mosheh/codebase.py/#consts","title":"Consts","text":"<p>NO CONSTANT DEFINED HERE</p>"},{"location":"Codebase/mosheh/codebase.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"Codebase/mosheh/codebase.py/#functions","title":"Functions","text":""},{"location":"Codebase/mosheh/codebase.py/#def-read_codebase","title":"<code>def read_codebase</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>root: str</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>CodebaseDict</code></p> Docstring <p>Iterates through the codebase and collects all info possibly needed.</p> <p>Using <code>_iterate()</code> to navigate, stores the collected data in a dict of type CodebaseDict, matching the file type and processing based on it.</p> <p>Also works as a dispatch-like, matching the files extensions, leading each file to its flow.</p> <p>:param root: The root path/dir to be iterated.</p> <p>:type root: str</p> <p>:return: All the codebase data collected.</p> <p>:rtype: CodebaseDict</p> Snippet Python<pre><code>def read_codebase(root: str) -&gt; CodebaseDict:\n    \"\"\"\n    Iterates through the codebase and collects all info possibly needed.\n\n    Using `_iterate()` to navigate, stores the collected data in a dict\n    of type CodebaseDict, matching the file type and processing based\n    on it.\n\n    Also works as a dispatch-like, matching the files extensions,\n    leading each file to its flow.\n\n    :param root: The root path/dir to be iterated.\n    :type root: str\n    :return: All the codebase data collected.\n    :rtype: CodebaseDict\n    \"\"\"\n    codebase: defaultdict[Any, Any] = nested_defaultdict()\n    for file in _iterate(root):\n        if file.endswith('.py') or file.endswith('.pyi'):\n            logger.info(f'Handling Python file: {file}')\n            codebase = handle_python_file(codebase, file)\n        else:\n            logger.info(f'File not handled: {file}')\n    return convert_to_regular_dict(codebase)\n</code></pre>"},{"location":"Codebase/mosheh/codebase.py/#def-_iterate","title":"<code>def _iterate</code>","text":"<p>Type: <code>generator</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>root: str</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>Generator[str, Any, Any]</code></p> Docstring <p>Iterates through every dir and file starting at provided root.</p> <p>Iterates using for-loop in os.walk and for dirpath and file in files yields the path for each file from the provided root to it.</p> <p>:param root: The root to be used as basedir.</p> <p>:type root: str</p> <p>:return: The path for each file on for-loop.</p> <p>:rtype: Generator[str, Any, Any]</p> Snippet Python<pre><code>def _iterate(root: str) -&gt; Generator[str, Any, Any]:\n    \"\"\"\n    Iterates through every dir and file starting at provided root.\n\n    Iterates using for-loop in os.walk and for dirpath and file in\n    files yields the path for each file from the provided root to it.\n\n    :param root: The root to be used as basedir.\n    :type root: str\n    :return: The path for each file on for-loop.\n    :rtype: Generator[str, Any, Any]\n    \"\"\"\n    for dirpath, _, files in walk(root):\n        for file in files:\n            yield path.join(dirpath, file)\n</code></pre>"},{"location":"Codebase/mosheh/codebase.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"Codebase/mosheh/constants.py/","title":"File: <code>constants.py</code>","text":"<p>Role:  Python Source Code</p> <p>Path: <code>mosheh</code></p> <p>This module defines constants and templates used throughout the project.</p> <p>It aims to standardize project-wide values, ensure consistency, and streamline the development and documentation process.</p> <p>The constants defined here are:</p> <ol> <li> <p><code>BUILTIN_MODULES</code>: A comprehensive <code>sorted</code> object of Python's built-in modules for     reference or validation purposes.</p> </li> <li> <p><code>BUILTIN_FUNCTIONS</code>: A <code>sorted</code> object of Python's built-in functions to support     validation, documentation or tooling needs.</p> </li> <li> <p><code>BUILTIN_DUNDER_METHODS</code>: A <code>sorted</code> object commonly used double-underscore (dunder)     methods in Python, aiding in validation or documentation.</p> </li> <li> <p><code>ACCEPTABLE_LOWER_CONSTANTS</code>: Lowercase constants acceptable in the project to     enforce naming conventions.</p> </li> <li> <p><code>DEFAULT_MKDOCS_YML</code>: A template for MkDocs configuration using the Material theme,     with custom settings for a consistent and professional documentation structure.</p> </li> <li> <p>Markdown Templates:</p> <ul> <li>Files (<code>FILE_MARKDOWN</code>)</li> <li>Imports (<code>IMPORT_MD_STRUCT</code>)</li> <li>Assignments (<code>ASSIGN_MD_STRUCT</code>)</li> <li>Classes (<code>CLASS_DEF_MD_STRUCT</code>)</li> <li>Functions (<code>FUNCTION_DEF_MD_STRUCT</code>)</li> <li>Assertions (<code>ASSERT_MD_STRUCT</code>)</li> </ul> </li> </ol> <p>These constants can be imported and reused wherever needed in the project. Be careful when updating this file to maintain consistency across the project. Remember that this file should remain immutable during runtime and utilize Python's <code>typing.Final</code> type hint to mark constants as non-overridable.</p>"},{"location":"Codebase/mosheh/constants.py/#imports","title":"Imports","text":""},{"location":"Codebase/mosheh/constants.py/#import-builtins","title":"<code>import builtins</code>","text":"<p>Path: <code>None</code></p> <p>Category: native</p> Snippet Python<pre><code>import builtins\n</code></pre>"},{"location":"Codebase/mosheh/constants.py/#import-isclass","title":"<code>import isclass</code>","text":"<p>Path: <code>inspect</code></p> <p>Category: native</p> Snippet Python<pre><code>from inspect import isclass\n</code></pre>"},{"location":"Codebase/mosheh/constants.py/#import-version_info","title":"<code>import version_info</code>","text":"<p>Path: <code>sys</code></p> <p>Category: native</p> Snippet Python<pre><code>from sys import version_info\n</code></pre>"},{"location":"Codebase/mosheh/constants.py/#import-builtinfunctiontype","title":"<code>import BuiltinFunctionType</code>","text":"<p>Path: <code>types</code></p> <p>Category: native</p> Snippet Python<pre><code>from types import BuiltinFunctionType\n</code></pre>"},{"location":"Codebase/mosheh/constants.py/#import-final","title":"<code>import Final</code>","text":"<p>Path: <code>typing</code></p> <p>Category: native</p> Snippet Python<pre><code>from typing import Final\n</code></pre>"},{"location":"Codebase/mosheh/constants.py/#import-stdlib_list","title":"<code>import stdlib_list</code>","text":"<p>Path: <code>stdlib_list</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from stdlib_list import stdlib_list\n</code></pre>"},{"location":"Codebase/mosheh/constants.py/#consts","title":"Consts","text":""},{"location":"Codebase/mosheh/constants.py/#builtin_modules","title":"<code>BUILTIN_MODULES</code>","text":"<p>Type: <code>Final[list[str]]</code></p> <p>Value: <code>sorted(stdlib_list(f'{version_info.major}.{version_info.minor}'))</code></p> Snippet Python<pre><code>BUILTIN_MODULES: Final[list[str]] = sorted(stdlib_list(f'{version_info.major}.{version_info.minor}'))\n</code></pre>"},{"location":"Codebase/mosheh/constants.py/#builtin_functions","title":"<code>BUILTIN_FUNCTIONS</code>","text":"<p>Type: <code>Final[list[str]]</code></p> <p>Value: <code>sorted((name for name in dir(builtins) if (obj := getattr(builtins, name)) is not None and (isinstance(obj, BuiltinFunctionType) or (isinstance(obj, type) and (not issubclass(obj, BaseException))))))</code></p> Snippet Python<pre><code>BUILTIN_FUNCTIONS: Final[list[str]] = sorted((name for name in dir(builtins) if (obj := getattr(builtins, name)) is not None and (isinstance(obj, BuiltinFunctionType) or (isinstance(obj, type) and (not issubclass(obj, BaseException))))))\n</code></pre>"},{"location":"Codebase/mosheh/constants.py/#builtin_dunder_methods","title":"<code>BUILTIN_DUNDER_METHODS</code>","text":"<p>Type: <code>Final[list[str]]</code></p> <p>Value: <code>sorted({attr for name in dir(builtins) if (cls := getattr(builtins, name)) is not None and isclass(cls) for attr in dir(cls) if attr.startswith('__') and attr.endswith('__')})</code></p> Snippet Python<pre><code>BUILTIN_DUNDER_METHODS: Final[list[str]] = sorted({attr for name in dir(builtins) if (cls := getattr(builtins, name)) is not None and isclass(cls) for attr in dir(cls) if attr.startswith('__') and attr.endswith('__')})\n</code></pre>"},{"location":"Codebase/mosheh/constants.py/#acceptable_lower_constants","title":"<code>ACCEPTABLE_LOWER_CONSTANTS</code>","text":"<p>Type: <code>Final[tuple[str, ...]]</code></p> <p>Value: <code>('__author__', '__copyright__', '__credits__', '__date__', '__email__', '__keywords__', '__license__', '__maintainer__', '__repository__', '__status__', '__version__', 'app', 'app_name', 'application', 'main', 'urlpatterns')</code></p> Snippet Python<pre><code>ACCEPTABLE_LOWER_CONSTANTS: Final[tuple[str, ...]] = ('__author__', '__copyright__', '__credits__', '__date__', '__email__', '__keywords__', '__license__', '__maintainer__', '__repository__', '__status__', '__version__', 'app', 'app_name', 'application', 'main', 'urlpatterns')\n</code></pre>"},{"location":"Codebase/mosheh/constants.py/#default_mkdocs_yml","title":"<code>DEFAULT_MKDOCS_YML</code>","text":"<p>Type: <code>Final[str]</code></p> <p>Value: <code>'site_name: {proj_name}\\nsite_url: {site_url}\\nrepo_url: {repo_url}\\nrepo_name: {repo_name}\\nedit_uri: \"{edit_uri}\"\\n\\n\\ntheme:\\n  name: material\\n  language: en\\n  favicon: {logo_path}\\n  logo: {logo_path}\\n  font:\\n    text: Ubuntu\\n\\n  icon:\\n    next: fontawesome/solid/arrow-right\\n    previous: fontawesome/solid/arrow-left\\n    top: fontawesome/solid/arrow-up\\n    repo: fontawesome/brands/git-alt\\n    edit: material/pencil\\n    view: material/eye\\n\\n    tag:\\n      homepage: fontawesome/solid/house\\n      index: fontawesome/solid/file\\n      overview: fontawesome/solid/binoculars\\n      test: fontawesome/solid/flask-vial\\n      infra: fontawesome/solid/server\\n      doc: fontawesome/solid/book\\n      legal: fontawesome/solid/scale-unbalanced\\n      user: fontawesome/solid/user\\n      API: fontawesome/solid/gears\\n      browser: fontawesome/solid/desktop\\n\\n    admonition:\\n      note: fontawesome/solid/note-sticky\\n      abstract: fontawesome/solid/book\\n      info: fontawesome/solid/circle-info\\n      tip: fontawesome/solid/fire-flame-simple\\n      success: fontawesome/solid/check\\n      question: fontawesome/solid/circle-question\\n      warning: fontawesome/solid/triangle-exclamation\\n      failure: fontawesome/solid/xmark\\n      danger: fontawesome/solid/skull\\n      bug: fontawesome/solid/bug\\n      example: fontawesome/solid/flask\\n      quote: fontawesome/solid/quote-left\\n\\n  palette:\\n    # Palette toggle for light mode\\n    - scheme: default\\n      toggle:\\n        icon: material/brightness-7\\n        name: Light/Dark Mode\\n      primary: green\\n      accent: indigo\\n\\n    # Palette toggle for dark mode\\n    - scheme: slate\\n      toggle:\\n        icon: material/brightness-3\\n        name: Light/Dark Mode\\n      primary: teal\\n      accent: orange\\n\\n\\n  features:\\n    - navigation.indexes\\n    - navigation.tabs\\n    - navigation.top\\n    - header.autohide\\n    - navigation.footer\\n    - content.action.view\\n    - content.action.edit\\n    - announce.dismiss\\n    - content.tabs.link\\n\\n\\nmarkdown_extensions:\\n  - attr_list\\n  - pymdownx.inlinehilite\\n  - pymdownx.snippets\\n  - admonition\\n  - pymdownx.details\\n  - md_in_html\\n  - def_list\\n  - pymdownx.emoji:\\n      emoji_index: !!python/name:material.extensions.emoji.twemoji\\n      emoji_generator: !!python/name:material.extensions.emoji.to_svg\\n  - pymdownx.highlight:\\n      anchor_linenums: true\\n      use_pygments: true\\n      pygments_lang_class: true\\n      auto_title: true\\n  - pymdownx.superfences:\\n      custom_fences:\\n        - name: mermaid\\n          class: mermaid\\n          format: !!python/name:pymdownx.superfences.fence_code_format\\n  - pymdownx.tabbed:\\n      alternate_style: true\\n  - pymdownx.arithmatex:\\n      generic: true\\n  - pymdownx.tasklist:\\n      custom_checkbox: true\\n      clickable_checkbox: false\\n\\n\\nplugins:\\n  - search\\n  - tags\\n  - git-revision-date-localized:\\n      enable_creation_date: true\\n      type: datetime\\n      enabled: true\\n      fallback_to_build_date: true\\n      locale: en\\n\\n\\nextra:\\n  tags:\\n    Homepage: homepage\\n    Index: index\\n    Overview: overview\\n    Test: test\\n    Infra: infra\\n    Documentation: doc\\n    Legal: legal\\n    User: user\\n    API: API\\n    Browser: browser\\n\\n  status:\\n    new: Recently Added!\\n\\n\\ncopyright: Only God knows\\n\\nnav:\\n  - Homepage: index.md\\n  - {codebase_nav_path}:\\n    - main.py: main.py.md\\n\\n'</code></p> Snippet Python<pre><code>DEFAULT_MKDOCS_YML: Final[str] = 'site_name: {proj_name}\\nsite_url: {site_url}\\nrepo_url: {repo_url}\\nrepo_name: {repo_name}\\nedit_uri: \"{edit_uri}\"\\n\\n\\ntheme:\\n  name: material\\n  language: en\\n  favicon: {logo_path}\\n  logo: {logo_path}\\n  font:\\n    text: Ubuntu\\n\\n  icon:\\n    next: fontawesome/solid/arrow-right\\n    previous: fontawesome/solid/arrow-left\\n    top: fontawesome/solid/arrow-up\\n    repo: fontawesome/brands/git-alt\\n    edit: material/pencil\\n    view: material/eye\\n\\n    tag:\\n      homepage: fontawesome/solid/house\\n      index: fontawesome/solid/file\\n      overview: fontawesome/solid/binoculars\\n      test: fontawesome/solid/flask-vial\\n      infra: fontawesome/solid/server\\n      doc: fontawesome/solid/book\\n      legal: fontawesome/solid/scale-unbalanced\\n      user: fontawesome/solid/user\\n      API: fontawesome/solid/gears\\n      browser: fontawesome/solid/desktop\\n\\n    admonition:\\n      note: fontawesome/solid/note-sticky\\n      abstract: fontawesome/solid/book\\n      info: fontawesome/solid/circle-info\\n      tip: fontawesome/solid/fire-flame-simple\\n      success: fontawesome/solid/check\\n      question: fontawesome/solid/circle-question\\n      warning: fontawesome/solid/triangle-exclamation\\n      failure: fontawesome/solid/xmark\\n      danger: fontawesome/solid/skull\\n      bug: fontawesome/solid/bug\\n      example: fontawesome/solid/flask\\n      quote: fontawesome/solid/quote-left\\n\\n  palette:\\n    # Palette toggle for light mode\\n    - scheme: default\\n      toggle:\\n        icon: material/brightness-7\\n        name: Light/Dark Mode\\n      primary: green\\n      accent: indigo\\n\\n    # Palette toggle for dark mode\\n    - scheme: slate\\n      toggle:\\n        icon: material/brightness-3\\n        name: Light/Dark Mode\\n      primary: teal\\n      accent: orange\\n\\n\\n  features:\\n    - navigation.indexes\\n    - navigation.tabs\\n    - navigation.top\\n    - header.autohide\\n    - navigation.footer\\n    - content.action.view\\n    - content.action.edit\\n    - announce.dismiss\\n    - content.tabs.link\\n\\n\\nmarkdown_extensions:\\n  - attr_list\\n  - pymdownx.inlinehilite\\n  - pymdownx.snippets\\n  - admonition\\n  - pymdownx.details\\n  - md_in_html\\n  - def_list\\n  - pymdownx.emoji:\\n      emoji_index: !!python/name:material.extensions.emoji.twemoji\\n      emoji_generator: !!python/name:material.extensions.emoji.to_svg\\n  - pymdownx.highlight:\\n      anchor_linenums: true\\n      use_pygments: true\\n      pygments_lang_class: true\\n      auto_title: true\\n  - pymdownx.superfences:\\n      custom_fences:\\n        - name: mermaid\\n          class: mermaid\\n          format: !!python/name:pymdownx.superfences.fence_code_format\\n  - pymdownx.tabbed:\\n      alternate_style: true\\n  - pymdownx.arithmatex:\\n      generic: true\\n  - pymdownx.tasklist:\\n      custom_checkbox: true\\n      clickable_checkbox: false\\n\\n\\nplugins:\\n  - search\\n  - tags\\n  - git-revision-date-localized:\\n      enable_creation_date: true\\n      type: datetime\\n      enabled: true\\n      fallback_to_build_date: true\\n      locale: en\\n\\n\\nextra:\\n  tags:\\n    Homepage: homepage\\n    Index: index\\n    Overview: overview\\n    Test: test\\n    Infra: infra\\n    Documentation: doc\\n    Legal: legal\\n    User: user\\n    API: API\\n    Browser: browser\\n\\n  status:\\n    new: Recently Added!\\n\\n\\ncopyright: Only God knows\\n\\nnav:\\n  - Homepage: index.md\\n  - {codebase_nav_path}:\\n    - main.py: main.py.md\\n\\n'\n</code></pre>"},{"location":"Codebase/mosheh/constants.py/#file_markdown","title":"<code>FILE_MARKDOWN</code>","text":"<p>Type: <code>Final[str]</code></p> <p>Value: <code>'# File:</code><code>\\n\\nRole: {role}\\n\\nPath:</code><code>\\n\\n{filedoc}\\n\\n---\\n\\n## Imports\\n\\n{imports}\\n\\n---\\n\\n## Consts\\n\\n{constants}\\n\\n---\\n\\n## Classes\\n\\n{classes}\\n\\n---\\n\\n## Functions\\n\\n{functions}\\n\\n---\\n\\n## Assertions\\n\\n{assertions}\\n'</code></p> Snippet Python<pre><code>FILE_MARKDOWN: Final[str] = '# File: `{filename}`\\n\\nRole: {role}\\n\\nPath: `{file_path}`\\n\\n{filedoc}\\n\\n---\\n\\n## Imports\\n\\n{imports}\\n\\n---\\n\\n## Consts\\n\\n{constants}\\n\\n---\\n\\n## Classes\\n\\n{classes}\\n\\n---\\n\\n## Functions\\n\\n{functions}\\n\\n---\\n\\n## Assertions\\n\\n{assertions}\\n'\n</code></pre>"},{"location":"Codebase/mosheh/constants.py/#import_md_struct","title":"<code>IMPORT_MD_STRUCT</code>","text":"<p>Type: <code>Final[str]</code></p> <p>Value: <code>'###</code>#!py import {name}<code>\\n\\nPath:</code>#!py {_path}<code>\\n\\nCategory: {category}\\n\\n??? example \"Snippet\"\\n\\n    ```py\\n{code}\\n    ```\\n\\n'</code></p> Snippet Python<pre><code>IMPORT_MD_STRUCT: Final[str] = '### `#!py import {name}`\\n\\nPath: `#!py {_path}`\\n\\nCategory: {category}\\n\\n??? example \"Snippet\"\\n\\n    ```py\\n{code}\\n    ```\\n\\n'\n</code></pre>"},{"location":"Codebase/mosheh/constants.py/#assign_md_struct","title":"<code>ASSIGN_MD_STRUCT</code>","text":"<p>Type: <code>Final[str]</code></p> <p>Value: <code>'###</code>#!py {token}<code>\\n\\nType:</code>#!py {_type}<code>\\n\\nValue:</code>#!py {value}<code>\\n\\n??? example \"Snippet\"\\n\\n    ```py\\n{code}\\n    ```\\n\\n'</code></p> Snippet Python<pre><code>ASSIGN_MD_STRUCT: Final[str] = '### `#!py {token}`\\n\\nType: `#!py {_type}`\\n\\nValue: `#!py {value}`\\n\\n??? example \"Snippet\"\\n\\n    ```py\\n{code}\\n    ```\\n\\n'\n</code></pre>"},{"location":"Codebase/mosheh/constants.py/#class_def_md_struct","title":"<code>CLASS_DEF_MD_STRUCT</code>","text":"<p>Type: <code>Final[str]</code></p> <p>Value: <code>'###</code>#!py class {name}<code>\\n\\nParents:</code><code>\\n\\nDecorators:</code>#!py {decorators}<code>\\n\\nKwargs:</code>#!py {kwargs}<code>\\n\\n??? quote \"Docstring\"\\n\\n{docstring}\\n\\n??? example \"Snippet\"\\n\\n    ```py\\n{code}\\n    ```\\n\\n'</code></p> Snippet Python<pre><code>CLASS_DEF_MD_STRUCT: Final[str] = '### `#!py class {name}`\\n\\nParents: `{inheritance}`\\n\\nDecorators: `#!py {decorators}`\\n\\nKwargs: `#!py {kwargs}`\\n\\n??? quote \"Docstring\"\\n\\n{docstring}\\n\\n??? example \"Snippet\"\\n\\n    ```py\\n{code}\\n    ```\\n\\n'\n</code></pre>"},{"location":"Codebase/mosheh/constants.py/#function_def_md_struct","title":"<code>FUNCTION_DEF_MD_STRUCT</code>","text":"<p>Type: <code>Final[str]</code></p> <p>Value: <code>'###</code>#!py def {name}<code>\\n\\nType:</code>#!py {category}<code>\\n\\nDecorators:</code>#!py {decorators}<code>\\n\\nArgs:</code>#!py {args}<code>\\n\\nKwargs:</code>#!py {kwargs}<code>\\n\\nReturn Type:</code>#!py {rtype}<code>\\n\\n??? quote \"Docstring\"\\n\\n{docstring}\\n\\n??? example \"Snippet\"\\n\\n    ```py\\n{code}\\n    ```\\n\\n'</code></p> Snippet Python<pre><code>FUNCTION_DEF_MD_STRUCT: Final[str] = '### `#!py def {name}`\\n\\nType: `#!py {category}`\\n\\nDecorators: `#!py {decorators}`\\n\\nArgs: `#!py {args}`\\n\\nKwargs: `#!py {kwargs}`\\n\\nReturn Type: `#!py {rtype}`\\n\\n??? quote \"Docstring\"\\n\\n{docstring}\\n\\n??? example \"Snippet\"\\n\\n    ```py\\n{code}\\n    ```\\n\\n'\n</code></pre>"},{"location":"Codebase/mosheh/constants.py/#assert_md_struct","title":"<code>ASSERT_MD_STRUCT</code>","text":"<p>Type: <code>Final[str]</code></p> <p>Value: <code>'###</code>#!py assert {test}<code>\\n\\nMessage:</code>#!py {msg}<code>\\n\\n??? example \"Snippet\"\\n\\n    ```py\\n{code}\\n    ```\\n\\n'</code></p> Snippet Python<pre><code>ASSERT_MD_STRUCT: Final[str] = '### `#!py assert {test}`\\n\\nMessage: `#!py {msg}`\\n\\n??? example \"Snippet\"\\n\\n    ```py\\n{code}\\n    ```\\n\\n'\n</code></pre>"},{"location":"Codebase/mosheh/constants.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"Codebase/mosheh/constants.py/#functions","title":"Functions","text":"<p>NO FUNCTION DEFINED HERE</p>"},{"location":"Codebase/mosheh/constants.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"Codebase/mosheh/main.py/","title":"File: <code>main.py</code>","text":"<p>Role:  Python Source Code</p> <p>Path: <code>mosheh</code></p> <p>Mosheh, automatic and elegant documentation of Python code with MkDocs.</p> <p>Inspirated by <code>cargodoc</code> - a Rust tool for code documenting - and using MkDocs + Material MkDocs, Mosheh is an easy, fast, plug-and-play tool which saves time while automating the process of documenting the source code of a Python codebase.</p> <p>The stuff documented for each file is avaible at https://lucasgoncsilva.github.io/mosheh</p>"},{"location":"Codebase/mosheh/main.py/#imports","title":"Imports","text":""},{"location":"Codebase/mosheh/main.py/#import-argumentparser","title":"<code>import ArgumentParser</code>","text":"<p>Path: <code>argparse</code></p> <p>Category: native</p> Snippet Python<pre><code>from argparse import ArgumentParser\n</code></pre>"},{"location":"Codebase/mosheh/main.py/#import-namespace","title":"<code>import Namespace</code>","text":"<p>Path: <code>argparse</code></p> <p>Category: native</p> Snippet Python<pre><code>from argparse import Namespace\n</code></pre>"},{"location":"Codebase/mosheh/main.py/#import-rawdescriptionhelpformatter","title":"<code>import RawDescriptionHelpFormatter</code>","text":"<p>Path: <code>argparse</code></p> <p>Category: native</p> Snippet Python<pre><code>from argparse import RawDescriptionHelpFormatter\n</code></pre>"},{"location":"Codebase/mosheh/main.py/#import-critical","title":"<code>import CRITICAL</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import CRITICAL\n</code></pre>"},{"location":"Codebase/mosheh/main.py/#import-debug","title":"<code>import DEBUG</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import DEBUG\n</code></pre>"},{"location":"Codebase/mosheh/main.py/#import-error","title":"<code>import ERROR</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import ERROR\n</code></pre>"},{"location":"Codebase/mosheh/main.py/#import-info","title":"<code>import INFO</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import INFO\n</code></pre>"},{"location":"Codebase/mosheh/main.py/#import-warning","title":"<code>import WARNING</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import WARNING\n</code></pre>"},{"location":"Codebase/mosheh/main.py/#import-basicconfig","title":"<code>import basicConfig</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import basicConfig\n</code></pre>"},{"location":"Codebase/mosheh/main.py/#import-getlogger","title":"<code>import getLogger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import getLogger\n</code></pre>"},{"location":"Codebase/mosheh/main.py/#import-richhandler","title":"<code>import RichHandler</code>","text":"<p>Path: <code>rich.logging</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from rich.logging import RichHandler\n</code></pre>"},{"location":"Codebase/mosheh/main.py/#import-create","title":"<code>import create</code>","text":"<p>Path: <code>mosheh.commands</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.commands import create\n</code></pre>"},{"location":"Codebase/mosheh/main.py/#import-init","title":"<code>import init</code>","text":"<p>Path: <code>mosheh.commands</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.commands import init\n</code></pre>"},{"location":"Codebase/mosheh/main.py/#import-update","title":"<code>import update</code>","text":"<p>Path: <code>mosheh.commands</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.commands import update\n</code></pre>"},{"location":"Codebase/mosheh/main.py/#consts","title":"Consts","text":"<p>NO CONSTANT DEFINED HERE</p>"},{"location":"Codebase/mosheh/main.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"Codebase/mosheh/main.py/#functions","title":"Functions","text":""},{"location":"Codebase/mosheh/main.py/#def-set_logging_config","title":"<code>def set_logging_config</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>v: int</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>None</code></p> Docstring <p>Configures the logging level for the application based on the provided verbosity.</p> <p>Logging is handled using <code>RichHandler</code> for enhanced terminal output. The verbosity level <code>v</code> controls the logging granularity for the <code>mosheh</code> logger, and optionally for the <code>mkdocs</code> logger in debug mode.</p> <p>:param v: Verbosity level, from 0 (critical) to 4 (debug). Defaults to 3 (info).</p> Text Only<pre><code>- 0: Critical\n- 1: Error\n- 2: Warning\n- 3: Info (default)\n- 4: Debug\n</code></pre> <p>:type v: int = 3</p> <p>:return: None</p> <p>:rtype: None</p> Snippet Python<pre><code>def set_logging_config(v: int=3) -&gt; None:\n    \"\"\"\n    Configures the logging level for the application based on the provided verbosity.\n\n    Logging is handled using `RichHandler` for enhanced terminal output. The verbosity\n    level `v` controls the logging granularity for the `mosheh` logger, and optionally\n    for the `mkdocs` logger in debug mode.\n\n    :param v: Verbosity level, from 0 (critical) to 4 (debug). Defaults to 3 (info).\n\n        - 0: Critical\n        - 1: Error\n        - 2: Warning\n        - 3: Info (default)\n        - 4: Debug\n    :type v: int = 3\n    :return: None\n    :rtype: None\n    \"\"\"\n    basicConfig(format='%(message)s', handlers=[RichHandler()])\n    match v:\n        case 0:\n            getLogger('mosheh').setLevel(CRITICAL)\n        case 1:\n            getLogger('mosheh').setLevel(ERROR)\n        case 2:\n            getLogger('mosheh').setLevel(WARNING)\n        case 3:\n            getLogger('mosheh').setLevel(INFO)\n        case 4:\n            getLogger('mosheh').setLevel(DEBUG)\n        case _:\n            getLogger('mosheh').setLevel(INFO)\n</code></pre>"},{"location":"Codebase/mosheh/main.py/#def-main","title":"<code>def main</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>None</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>None</code></p> Docstring <p>This is the script's entrypoint, kinda where everything starts.</p> <p>It takes no parameters inside code itself, but uses ArgumentParser to deal with them. Parsing the args, extracts the infos provided to deal and construct the output doc based on them.</p> <p>:return: None</p> <p>:rtype: None</p> Snippet Python<pre><code>def main() -&gt; None:\n    \"\"\"\n    This is the script's entrypoint, kinda where everything starts.\n\n    It takes no parameters inside code itself, but uses ArgumentParser to deal with\n    them. Parsing the args, extracts the infos provided to deal and construct the\n    output doc based on them.\n\n    :return: None\n    :rtype: None\n    \"\"\"\n    parser: ArgumentParser = ArgumentParser(description=__doc__, formatter_class=RawDescriptionHelpFormatter)\n    subparsers = parser.add_subparsers(required=True)\n    parser_init = subparsers.add_parser('init', help='Creates the config file for using Mosheh.')\n    parser_init.add_argument('--path', type=str, default='.', help='Path for `mosheh.json` config file.')\n    parser_init.set_defaults(func=init)\n    parser_create = subparsers.add_parser('create', help='Creates the final documentation based on `mosheh.json`.')\n    parser_create.add_argument('--json', type=str, default='.', help='Path for `mosheh.json` config file.')\n    parser_create.set_defaults(func=create)\n    parser_update = subparsers.add_parser('update', help='Updates existing documentation \"nav.Codebase\" based on `mosheh.json` and reading the current codebase\\'s situation.')\n    parser_update.add_argument('--json', type=str, default='.', help='Path for `mosheh.json` config file.')\n    parser_update.set_defaults(func=update)\n    parser.add_argument('--verbose', type=int, default=3, choices=(0, 1, 2, 3, 4), help='Verbosity level, from 0 (quiet/critical) to 4 (overshare/debug).')\n    args: Namespace = parser.parse_args()\n    set_logging_config(args.verbose)\n    args.func(args)\n</code></pre>"},{"location":"Codebase/mosheh/main.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"Codebase/mosheh/utils.py/","title":"File: <code>utils.py</code>","text":"<p>Role:  Python Source Code</p> <p>Path: <code>mosheh</code></p> <p>If a func can help and be classified as an \"utility function\", problably that function is going to be here.</p> <p>Functions to be here must be independent, work isolated from other ones and decoupled away from any external or global logic. They must work just by itself, even if implementing some functionality which can be related.</p> <p>Here are usually maintained reusable code applicable everywhere.</p>"},{"location":"Codebase/mosheh/utils.py/#imports","title":"Imports","text":""},{"location":"Codebase/mosheh/utils.py/#import-importlibutil","title":"<code>import importlib.util</code>","text":"<p>Path: <code>None</code></p> <p>Category: native</p> Snippet Python<pre><code>import importlib.util\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#import-sysconfig","title":"<code>import sysconfig</code>","text":"<p>Path: <code>None</code></p> <p>Category: native</p> Snippet Python<pre><code>import sysconfig\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#import-bisect_left","title":"<code>import bisect_left</code>","text":"<p>Path: <code>bisect</code></p> <p>Category: native</p> Snippet Python<pre><code>from bisect import bisect_left\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#import-defaultdict","title":"<code>import defaultdict</code>","text":"<p>Path: <code>collections</code></p> <p>Category: native</p> Snippet Python<pre><code>from collections import defaultdict\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#import-sequence","title":"<code>import Sequence</code>","text":"<p>Path: <code>collections.abc</code></p> <p>Category: native</p> Snippet Python<pre><code>from collections.abc import Sequence\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#import-any","title":"<code>import Any</code>","text":"<p>Path: <code>typing</code></p> <p>Category: native</p> Snippet Python<pre><code>from typing import Any\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#import-cast","title":"<code>import cast</code>","text":"<p>Path: <code>typing</code></p> <p>Category: native</p> Snippet Python<pre><code>from typing import cast\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#import-builtin_modules","title":"<code>import BUILTIN_MODULES</code>","text":"<p>Path: <code>mosheh.constants</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.constants import BUILTIN_MODULES\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#import-codebasedict","title":"<code>import CodebaseDict</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import CodebaseDict\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#import-modulename","title":"<code>import ModuleName</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import ModuleName\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#import-standardreturn","title":"<code>import StandardReturn</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import StandardReturn\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#import-importtype","title":"<code>import ImportType</code>","text":"<p>Path: <code>mosheh.types.enums</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.enums import ImportType\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#consts","title":"Consts","text":"<p>NO CONSTANT DEFINED HERE</p>"},{"location":"Codebase/mosheh/utils.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"Codebase/mosheh/utils.py/#functions","title":"Functions","text":""},{"location":"Codebase/mosheh/utils.py/#def-bin","title":"<code>def bin</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>item: Any, universe: Sequence[Any]</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>bool</code></p> Docstring <p>Binary Search algorithm which returns not the index, but a boolean.</p> <p>Uses Python's bisect.bisect_left function to efficiently find the insertion point of the item in the sorted sequence, then checks if the item exists at that position.</p> <p>Example:</p> Python<pre><code>lst: list[int] = [1, 2, 3, 4, 5]\nnum: int = 4\nbin(num, lst)\n# True\n</code></pre> <p>:param item: The item to check if exists in.</p> <p>:type item: Any</p> <p>:param universe: The SORTED iterable to be evaluated.</p> <p>:type universe: Sequence[Any]</p> <p>:return: If the item is found in the universe.</p> <p>:rtype: bool</p> Snippet Python<pre><code>def bin(item: Any, universe: Sequence[Any]) -&gt; bool:\n    \"\"\"\n    Binary Search algorithm which returns not the index, but a boolean.\n\n    Uses Python's bisect.bisect_left function to efficiently find the insertion point\n    of the item in the sorted sequence, then checks if the item exists at that\n    position.\n\n    Example:\n\n    ```python\n    lst: list[int] = [1, 2, 3, 4, 5]\n    num: int = 4\n    bin(num, lst)\n    # True\n    ```\n\n    :param item: The item to check if exists in.\n    :type item: Any\n    :param universe: The SORTED iterable to be evaluated.\n    :type universe: Sequence[Any]\n    :return: If the item is found in the universe.\n    :rtype: bool\n    \"\"\"\n    i = bisect_left(universe, item)\n    return i &lt; len(universe) and universe[i] == item\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#def-get_import_type","title":"<code>def get_import_type</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>lib: ModuleName</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>ImportType</code></p> Docstring <p>Classifies the module into a valid <code>ImportType</code> alternative.</p> <p>By literally just... find spec using... unhh... find_spec()... searches for modules in the environment path and returns it.</p> <p>Example:</p> Python<pre><code>get_import_type('mkdocs')\n# ImportType.TrdParty\n</code></pre> <p>:param lib: The lib name, e.g. \"numpy\" or \"numba\".</p> <p>:type lib: ModuleName</p> <p>:return: <code>ImportType</code> enum for native, 3rd party or local one.</p> <p>:rtype: ImportType</p> Snippet Python<pre><code>def get_import_type(lib: ModuleName) -&gt; ImportType:\n    \"\"\"\n    Classifies the module into a valid `ImportType` alternative.\n\n    By literally just... find spec using... unhh... find_spec()... searches\n    for modules in the environment path and returns it.\n\n    Example:\n\n    ```python\n    get_import_type('mkdocs')\n    # ImportType.TrdParty\n    ```\n\n    :param lib: The lib name, e.g. \"numpy\" or \"numba\".\n    :type lib: ModuleName\n    :return: `ImportType` enum for native, 3rd party or local one.\n    :rtype: ImportType\n    \"\"\"\n    try:\n        if lib in BUILTIN_MODULES:\n            return ImportType.Native\n        spec = importlib.util.find_spec(lib)\n        if not spec or not spec.origin:\n            return ImportType.Local\n        origin: str = spec.origin\n        if origin in ('built-in', 'frozen') or (origin.endswith(('.so', '.pyd', '.dll')) and 'lib-dynload' in origin):\n            return ImportType.Native\n        if 'site-packages' in origin or 'dist-packages' in origin:\n            return ImportType.TrdParty\n        stdlib_path = sysconfig.get_paths()['stdlib']\n        if origin.startswith(stdlib_path):\n            return ImportType.Native\n        return ImportType.Local\n    except Exception:\n        return ImportType.Local\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#def-nested_defaultdict","title":"<code>def nested_defaultdict</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>None</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>defaultdict[Any, Any]</code></p> Docstring <p>Creates and returns a nested dictionary using <code>collections.defaultdict</code>.</p> <p>This function generates a <code>defaultdict</code> where each key defaults to another <code>nested_defaultdict</code>, allowing the creation of arbitrarily deep dictionaries without needing to explicitly define each level.</p> <p>Key concepts: - defaultdict: A specialized dictionary from the <code>collections</code> module   that automatically assigns a default value for missing keys. In this case, the   default value is another <code>nested_defaultdict</code>, enabling recursive dict nesting.</p> <p>Example:</p> Python<pre><code>d = nested_defaultdict()\nd['level1']['level2']['level3'] = 'text'\n# {'level': {'level2': {'level3': 'text'}}}\n</code></pre> <p>:return: A <code>defaultdict</code> instance configured for recursive nesting.</p> <p>:rtype: defaultdict[Any, Any]</p> Snippet Python<pre><code>def nested_defaultdict() -&gt; defaultdict[Any, Any]:\n    \"\"\"\n    Creates and returns a nested dictionary using `collections.defaultdict`.\n\n    This function generates a `defaultdict` where each key defaults to another\n    `nested_defaultdict`, allowing the creation of arbitrarily deep dictionaries without\n    needing to explicitly define each level.\n\n    Key concepts:\n    - defaultdict: A specialized dictionary from the `collections` module\n      that automatically assigns a default value for missing keys. In this case, the\n      default value is another `nested_defaultdict`, enabling recursive dict nesting.\n\n    Example:\n\n    ```python\n    d = nested_defaultdict()\n    d['level1']['level2']['level3'] = 'text'\n    # {'level': {'level2': {'level3': 'text'}}}\n    ```\n\n    :return: A `defaultdict` instance configured for recursive nesting.\n    :rtype: defaultdict[Any, Any]\n    \"\"\"\n    return defaultdict(nested_defaultdict)\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#def-add_to_nested_defaultdict","title":"<code>def add_to_nested_defaultdict</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>structure: defaultdict[Any, Any], path: list[str], data: list[StandardReturn]</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>defaultdict[Any, Any]</code></p> Docstring <p>Adds data to a nested dictionary structure based on a specified path.</p> <p>This function traverses a nested dictionary (<code>structure</code>) using a list of keys (<code>path</code>). If the path consists of a single key, the data is added directly to the corresponding level. Otherwise, the function recursively traverses deeper into the structure, creating nested dictionaries as needed, until the data is added at the specified location.</p> <p>Key concepts: - Recursive Traversal: The function calls itself recursively to traverse and modify   deeper levels of the nested dictionary.</p> <p>Example:</p> Python<pre><code>structure: defaultdict = nested_defaultdict()\npath: list[str] = ['level1', 'level2', 'level3']\ndata: list[StandardReturn] = [{'key': 'value'}]\nadd_to_nested_defaultdict(structure, path, data)\n# defaultdict(defaultdict, {'level1': {'level2': {'level3': [{'key': 'value'}]}}})\n</code></pre> <p>:param structure: The nested dictionary to modify.</p> <p>:type structure: defaultdict[Any, Any]</p> <p>:param path: A list of keys representing the path to the target location.</p> <p>:type path: list[str]</p> <p>:param data: The data to add at the specified path.</p> <p>:type data: list[StandardReturn]</p> <p>:return: The modified dictionary with the new data added.</p> <p>:rtype: defaultdict[Any, Any]</p> Snippet Python<pre><code>def add_to_nested_defaultdict(structure: defaultdict[Any, Any], path: list[str], data: list[StandardReturn]) -&gt; defaultdict[Any, Any]:\n    \"\"\"\n    Adds data to a nested dictionary structure based on a specified path.\n\n    This function traverses a nested dictionary (`structure`) using a list of keys\n    (`path`). If the path consists of a single key, the data is added directly to the\n    corresponding level. Otherwise, the function recursively traverses deeper into the\n    structure, creating nested dictionaries as needed, until the data is added at the\n    specified location.\n\n    Key concepts:\n    - Recursive Traversal: The function calls itself recursively to traverse and modify\n      deeper levels of the nested dictionary.\n\n    Example:\n\n    ```python\n    structure: defaultdict = nested_defaultdict()\n    path: list[str] = ['level1', 'level2', 'level3']\n    data: list[StandardReturn] = [{'key': 'value'}]\n    add_to_nested_defaultdict(structure, path, data)\n    # defaultdict(defaultdict, {'level1': {'level2': {'level3': [{'key': 'value'}]}}})\n    ```\n\n    :param structure: The nested dictionary to modify.\n    :type structure: defaultdict[Any, Any]\n    :param path: A list of keys representing the path to the target location.\n    :type path: list[str]\n    :param data: The data to add at the specified path.\n    :type data: list[StandardReturn]\n    :return: The modified dictionary with the new data added.\n    :rtype: defaultdict[Any, Any]\n    \"\"\"\n    if len(path) == 1:\n        structure[path[0]] = data\n    elif len(path) &gt; 1:\n        structure[path[0]] = add_to_nested_defaultdict(structure[path[0]], path[1:], data)\n    return structure\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#def-build_nav_struct","title":"<code>def build_nav_struct</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>tree: CodebaseDict, codebase_nav_path: str, prefix: str</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>list[dict[str, Any]]</code></p> Docstring <p>Processes the <code>codebase.read_codebase</code> into valid yaml \"Nav\" dump format.</p> <p>While taking the codebase structure, processed by <code>codebase.read_codebase</code> on the <code>Codebase</code> format, recursively iterates the codebase mapping every file and directory, returning something similar to the example below:</p> Python<pre><code>[\n    {\n        'PROJECT': [\n            {'manage.py': 'Codebase/PROJECT/manage.py.md'},\n            {\n                'dummy': [\n                    {'tests.py': 'Codebase/PROJECT/dummy/tests.py.md'},\n                    {'admin.py': 'Codebase/PROJECT/dummy/admin.py.md'},\n                    {'apps.py': 'Codebase/PROJECT/dummy/apps.py.md'},\n                    {'models.py': 'Codebase/PROJECT/dummy/models.py.md'},\n                    {'urls.py': 'Codebase/PROJECT/dummy/urls.py.md'},\n                    {'__init__.py': 'Codebase/PROJECT/dummy/__init__.py.md'},\n                    {'views.py': 'Codebase/PROJECT/dummy/views.py.md'},\n                ]\n            },\n            {\n                'CORE': [\n                    {'wsgi.py': 'Codebase/PROJECT/CORE/wsgi.py.md'},\n                    {'asgi.py': 'Codebase/PROJECT/CORE/asgi.py.md'},\n                    {'urls.py': 'Codebase/PROJECT/CORE/urls.py.md'},\n                    {'settings.py': 'Codebase/PROJECT/CORE/settings.py.md'},\n                    {'__init__.py': 'Codebase/PROJECT/CORE/__init__.py.md'},\n                ]\n            },\n        ]\n    }\n]\n</code></pre> <p>The directories has a list as key-value pair, while files has their markdown equivalent path for their markdown documented result.</p> <p>:param tree: Codebase <code>codebase.read_codebase</code> struct.</p> <p>:type tree: Codebase</p> <p>:param codebase_nav_path: Expected codebase nav name to be used/found.</p> <p>:type codebase_nav_path: str = 'Codebase'</p> <p>:param prefix: Accumulative string path for concat.</p> <p>:type tree: str = ''</p> <p>:return: Formatted \"yaml-nav-dumpable\" codebase structure.</p> <p>:rtype: list[dict[str, Any]]</p> Snippet Python<pre><code>def build_nav_struct(tree: CodebaseDict, codebase_nav_path: str='Codebase', prefix: str='') -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Processes the `codebase.read_codebase` into valid yaml \"Nav\" dump format.\n\n    While taking the codebase structure, processed by `codebase.read_codebase` on the\n    `Codebase` format, recursively iterates the codebase mapping every file and\n    directory, returning something similar to the example below:\n\n    ```python\n    [\n        {\n            'PROJECT': [\n                {'manage.py': 'Codebase/PROJECT/manage.py.md'},\n                {\n                    'dummy': [\n                        {'tests.py': 'Codebase/PROJECT/dummy/tests.py.md'},\n                        {'admin.py': 'Codebase/PROJECT/dummy/admin.py.md'},\n                        {'apps.py': 'Codebase/PROJECT/dummy/apps.py.md'},\n                        {'models.py': 'Codebase/PROJECT/dummy/models.py.md'},\n                        {'urls.py': 'Codebase/PROJECT/dummy/urls.py.md'},\n                        {'__init__.py': 'Codebase/PROJECT/dummy/__init__.py.md'},\n                        {'views.py': 'Codebase/PROJECT/dummy/views.py.md'},\n                    ]\n                },\n                {\n                    'CORE': [\n                        {'wsgi.py': 'Codebase/PROJECT/CORE/wsgi.py.md'},\n                        {'asgi.py': 'Codebase/PROJECT/CORE/asgi.py.md'},\n                        {'urls.py': 'Codebase/PROJECT/CORE/urls.py.md'},\n                        {'settings.py': 'Codebase/PROJECT/CORE/settings.py.md'},\n                        {'__init__.py': 'Codebase/PROJECT/CORE/__init__.py.md'},\n                    ]\n                },\n            ]\n        }\n    ]\n    ```\n\n    The directories has a list as key-value pair, while files has their markdown\n    equivalent path for their markdown documented result.\n\n    :param tree: Codebase `codebase.read_codebase` struct.\n    :type tree: Codebase\n    :param codebase_nav_path: Expected codebase nav name to be used/found.\n    :type codebase_nav_path: str = 'Codebase'\n    :param prefix: Accumulative string path for concat.\n    :type tree: str = ''\n    :return: Formatted \"yaml-nav-dumpable\" codebase structure.\n    :rtype: list[dict[str, Any]]\n    \"\"\"\n    result: list[dict[str, Any]] = []\n    for name, content in cast(dict[str, Any], tree).items():\n        full_path = f'{prefix}/{name}' if prefix else name\n        if isinstance(content, list):\n            result.append({name: f'{codebase_nav_path}/{full_path}.md'})\n        else:\n            nested: list[dict[str, Any]] = build_nav_struct(content, codebase_nav_path, full_path)\n            result.append({name: nested})\n    return result\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#def-convert_to_regular_dict","title":"<code>def convert_to_regular_dict</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>d: defaultdict[Any, Any] | dict[Any, Any]</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>CodebaseDict</code></p> Docstring <p>Converts a nested <code>defaultdict</code> into a regular dictionary.</p> <p>This function recursively traverses a <code>defaultdict</code> and its nested dictionaries, converting all instances of <code>defaultdict</code> into standard Python dictionaries. This ensures the resulting structure is free of <code>defaultdict</code> behavior.</p> <p>Key concepts: - defaultdict: A dictionary subclass from the <code>collections</code> module that provides   default values for missing keys. This func removes that behavior by converting   it into a regular dictionary. - Recursive Conversion: The function traverses and converts all nested dict,   ensuring the entire structure is converted.</p> <p>Example:</p> Python<pre><code>d: defaultdict = nested_defaultdict()\nd['level1']['level2'] = 'value'\nconvert_to_regular_dict(d)\n# {'level1': {'level2': 'value'}}\n</code></pre> <p>:param d: The dictionary to convert. Can include nested <code>defaultdict</code> instances.</p> <p>:type d: defaultdict[Any, Any] | dict[Any, Any]</p> <p>:return: A dict where all <code>defaultdict</code> instances are converted to regular dicts.</p> <p>:rtype: CodebaseDict</p> Snippet Python<pre><code>def convert_to_regular_dict(d: defaultdict[Any, Any] | dict[Any, Any]) -&gt; CodebaseDict:\n    \"\"\"\n    Converts a nested `defaultdict` into a regular dictionary.\n\n    This function recursively traverses a `defaultdict` and its nested dictionaries,\n    converting all instances of `defaultdict` into standard Python dictionaries. This\n    ensures the resulting structure is free of `defaultdict` behavior.\n\n    Key concepts:\n    - defaultdict: A dictionary subclass from the `collections` module that provides\n      default values for missing keys. This func removes that behavior by converting\n      it into a regular dictionary.\n    - Recursive Conversion: The function traverses and converts all nested dict,\n      ensuring the entire structure is converted.\n\n    Example:\n\n    ```python\n    d: defaultdict = nested_defaultdict()\n    d['level1']['level2'] = 'value'\n    convert_to_regular_dict(d)\n    # {'level1': {'level2': 'value'}}\n    ```\n\n    :param d: The dictionary to convert. Can include nested `defaultdict` instances.\n    :type d: defaultdict[Any, Any] | dict[Any, Any]\n    :return: A dict where all `defaultdict` instances are converted to regular dicts.\n    :rtype: CodebaseDict\n    \"\"\"\n    if isinstance(d, defaultdict):\n        d = {k: convert_to_regular_dict(v) for k, v in d.items()}\n    return d\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#def-standard_struct","title":"<code>def standard_struct</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>None</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>StandardReturn</code></p> Docstring <p>Defines the standard keys and values of code data dict.</p> <p>The keys are listed below, followed by they types, as below:</p> <p>Python<pre><code>dct: StandardReturn = {\n    'statement': Statement,\n    'name': Token,\n    'tokens': list[Token | ImportedIdentifier],\n    'annot': Annotation,\n    'value': Value,\n    'decorators': list[Decorator],\n    'inheritance': list[Inheritance],\n    'path': ModulePath,\n    'category': ImportType | FunctionType,\n    'docstring': Docstring | None,\n    'rtype': Annotation,\n    'args': Arg,\n    'kwargs': Kwarg,\n    'test': AssertionTest,\n    'msg': AssertionMessage,\n    'code': CodeSnippet,\n}\n</code></pre> Any other datatype different from those above must be avoided as much as possible to maintain the codebase at the same struct. Python is not the best when talking about types like Java or Rust, so keep this in mind is really necessary.</p> <p>Example:</p> Python<pre><code>standard_struct()\n# {}\n</code></pre> <p>:return: An empty dict annotated with special custom type.</p> <p>:rtype: StandardReturn</p> Snippet Python<pre><code>def standard_struct() -&gt; StandardReturn:\n    \"\"\"\n    Defines the standard keys and values of code data dict.\n\n    The keys are listed below, followed by they types, as below:\n\n    ```python\n    dct: StandardReturn = {\n        'statement': Statement,\n        'name': Token,\n        'tokens': list[Token | ImportedIdentifier],\n        'annot': Annotation,\n        'value': Value,\n        'decorators': list[Decorator],\n        'inheritance': list[Inheritance],\n        'path': ModulePath,\n        'category': ImportType | FunctionType,\n        'docstring': Docstring | None,\n        'rtype': Annotation,\n        'args': Arg,\n        'kwargs': Kwarg,\n        'test': AssertionTest,\n        'msg': AssertionMessage,\n        'code': CodeSnippet,\n    }\n    ```\n    Any other datatype different from those above must be avoided as much as possible\n    to maintain the codebase at the same struct. Python is not the best when talking\n    about types like Java or Rust, so keep this in mind is really necessary.\n\n    Example:\n\n    ```python\n    standard_struct()\n    # {}\n    ```\n\n    :return: An empty dict annotated with special custom type.\n    :rtype: StandardReturn\n    \"\"\"\n    return {}\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#def-indent_code","title":"<code>def indent_code</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>code: str, level: int</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>str</code></p> Docstring Text Only<pre><code>Used just for applying indentation to code before building the doc `.md` file.\n\nBy receiving the code itself and an indentation number, defaulting to 4, and for\neach line applies the desired indentation level, A.K.A leftpad.\n\nExample:\n\n```python\ncode: str = \"\"\"for i in range(10):\n    str(i)\"\"\"\nlevel: int = 4\ncode\n# for i in range(10):\n</code></pre> Snippet Python<pre><code>def indent_code(code: str, level: int=4) -&gt; str:\n    '''\n    Used just for applying indentation to code before building the doc `.md` file.\n\n    By receiving the code itself and an indentation number, defaulting to 4, and for\n    each line applies the desired indentation level, A.K.A leftpad.\n\n    Example:\n\n    ```python\n    code: str = \"\"\"for i in range(10):\n        str(i)\"\"\"\n    level: int = 4\n    code\n    # for i in range(10):\n#     str(i)\n    indent_code(code, level)\n    #     for i in range(10):\n#         str(i)\n    ```\n\n    :param code: The code snippet to be formatted.\n    :type code: str\n    :param level: The number of spaces to leftpad each line.\n    :type level: int = 4\n    :return: The code snippet leftpadded.\n    :rtype: str\n    '''\n    indent: str = ' ' * level\n    new_code: str = '\\n'.join(map(lambda line: f'{indent}{line}' if line.strip() else '', code.splitlines()))\n    return new_code\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#stri","title":"str(i)","text":"Text Only<pre><code>indent_code(code, level)\n#     for i in range(10):\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#stri_1","title":"str(i)","text":"Text Only<pre><code>```\n</code></pre> <p>:param code: The code snippet to be formatted.</p> <p>:type code: str</p> <p>:param level: The number of spaces to leftpad each line.</p> <p>:type level: int = 4</p> <p>:return: The code snippet leftpadded.</p> <p>:rtype: str</p>"},{"location":"Codebase/mosheh/utils.py/#def-remove_abspath_from_codebase","title":"<code>def remove_abspath_from_codebase</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>d: CodebaseDict</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>CodebaseDict</code></p> Docstring <p>Removes abspath dirs names from <code>CodebaseDict</code> structure.</p> <p>Because of typing annotation stuff, this function just invokes the sibling with almost the same name, which is recursive, to handle the codebase-generated dict and remove any path outside the codebase but present due <code>os.path.abspath</code> calls.</p> <p>The output is exactly the same <code>CodebaseDict</code> but with no abspath dir present.</p> <p>:param d: <code>codebase.read_codebase</code> output structure.</p> <p>:type d: CodebaseDict</p> <p>:return: <code>codebase.read_codebase</code> output removing abspath.</p> <p>:rtype: CodebaseDict</p> Snippet Python<pre><code>def remove_abspath_from_codebase(d: CodebaseDict) -&gt; CodebaseDict:\n    \"\"\"\n    Removes abspath dirs names from `CodebaseDict` structure.\n\n    Because of typing annotation stuff, this function just invokes the sibling with\n    almost the same name, which is recursive, to handle the codebase-generated dict\n    and remove any path outside the codebase but present due `os.path.abspath` calls.\n\n    The output is exactly the same `CodebaseDict` but with no abspath dir present.\n\n    :param d: `codebase.read_codebase` output structure.\n    :type d: CodebaseDict\n    :return: `codebase.read_codebase` output removing abspath.\n    :rtype: CodebaseDict\n    \"\"\"\n    return _remove_abspath_from_codebase_helper(next(iter(d.values())))\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#def-_remove_abspath_from_codebase_helper","title":"<code>def _remove_abspath_from_codebase_helper</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>d: CodebaseDict | list[StandardReturn]</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>CodebaseDict</code></p> Docstring Snippet Python<pre><code>def _remove_abspath_from_codebase_helper(d: CodebaseDict | list[StandardReturn]) -&gt; CodebaseDict:\n    \"\"\"\n    ### YOU SHOULD NOT BE CALLING THIS FUNCTION!\n\n    Removes abspath dirs names from `CodebaseDict` structure.\n\n    The real recursive abspath-remove-o-matic function, not used primary just because\n    of typing annotations.\n\n    Inside it, recursively iterates the income `d`, goes until the first non-dictionary\n    or single-length item is found, returning from this point.\n\n    :param d: `codebase.read_codebase` output structure.\n    :type d: CodebaseDict | list[StandardReturn]\n    :return: `codebase.read_codebase` output removing abspath.\n    :rtype: CodebaseDict\n    \"\"\"\n    if isinstance(d, dict):\n        deeper = next(iter(d.values()))\n        if isinstance(deeper, dict) and len(deeper) == 1:\n            return _remove_abspath_from_codebase_helper(deeper)\n    return cast(CodebaseDict, d)\n</code></pre>"},{"location":"Codebase/mosheh/utils.py/#you-should-not-be-calling-this-function","title":"YOU SHOULD NOT BE CALLING THIS FUNCTION!","text":"<p>Removes abspath dirs names from <code>CodebaseDict</code> structure.</p> <p>The real recursive abspath-remove-o-matic function, not used primary just because of typing annotations.</p> <p>Inside it, recursively iterates the income <code>d</code>, goes until the first non-dictionary or single-length item is found, returning from this point.</p> <p>:param d: <code>codebase.read_codebase</code> output structure.</p> <p>:type d: CodebaseDict | list[StandardReturn]</p> <p>:return: <code>codebase.read_codebase</code> output removing abspath.</p> <p>:rtype: CodebaseDict</p>"},{"location":"Codebase/mosheh/utils.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"Codebase/mosheh/commands/__init__.py/","title":"File: <code>__init__.py</code>","text":"<p>Role:  Python Source Code</p> <p>Path: <code>mosheh.commands</code></p> <p>No file docstring provided.</p>"},{"location":"Codebase/mosheh/commands/__init__.py/#imports","title":"Imports","text":""},{"location":"Codebase/mosheh/commands/__init__.py/#import-create","title":"<code>import create</code>","text":"<p>Path: <code>mosheh.commands.create_cmd</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.commands.create_cmd import create\n</code></pre>"},{"location":"Codebase/mosheh/commands/__init__.py/#import-init","title":"<code>import init</code>","text":"<p>Path: <code>mosheh.commands.init_cmd</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.commands.init_cmd import init\n</code></pre>"},{"location":"Codebase/mosheh/commands/__init__.py/#import-update","title":"<code>import update</code>","text":"<p>Path: <code>mosheh.commands.update_cmd</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.commands.update_cmd import update\n</code></pre>"},{"location":"Codebase/mosheh/commands/__init__.py/#consts","title":"Consts","text":"<p>NO CONSTANT DEFINED HERE</p>"},{"location":"Codebase/mosheh/commands/__init__.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"Codebase/mosheh/commands/__init__.py/#functions","title":"Functions","text":"<p>NO FUNCTION DEFINED HERE</p>"},{"location":"Codebase/mosheh/commands/__init__.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"Codebase/mosheh/commands/create_cmd.py/","title":"File: <code>create_cmd.py</code>","text":"<p>Role:  Python Source Code</p> <p>Path: <code>mosheh.commands</code></p> <p>Encapsulating the <code>create</code> command logic, this file deals with the most important feature present on Mosheh: to create the codebase documentation.</p> <p>It seems extremely complex, but reading just a few lines shows that here is handled more about the IO and data validation from the <code>mosheh.json</code> config file than the logic implementation itself.</p>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#imports","title":"Imports","text":""},{"location":"Codebase/mosheh/commands/create_cmd.py/#import-namespace","title":"<code>import Namespace</code>","text":"<p>Path: <code>argparse</code></p> <p>Category: native</p> Snippet Python<pre><code>from argparse import Namespace\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#import-loads","title":"<code>import loads</code>","text":"<p>Path: <code>json</code></p> <p>Category: native</p> Snippet Python<pre><code>from json import loads\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#import-logger","title":"<code>import Logger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import Logger\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#import-getlogger","title":"<code>import getLogger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import getLogger\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#import-abspath","title":"<code>import abspath</code>","text":"<p>Path: <code>os.path</code></p> <p>Category: native</p> Snippet Python<pre><code>from os.path import abspath\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#import-join","title":"<code>import join</code>","text":"<p>Path: <code>os.path</code></p> <p>Category: native</p> Snippet Python<pre><code>from os.path import join\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#import-calledprocesserror","title":"<code>import CalledProcessError</code>","text":"<p>Path: <code>subprocess</code></p> <p>Category: native</p> Snippet Python<pre><code>from subprocess import CalledProcessError\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#import-read_codebase","title":"<code>import read_codebase</code>","text":"<p>Path: <code>mosheh.codebase</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.codebase import read_codebase\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#import-create_doc","title":"<code>import create_doc</code>","text":"<p>Path: <code>mosheh.doc.create</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.doc.create import create_doc\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#import-codebasedict","title":"<code>import CodebaseDict</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import CodebaseDict\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#import-iojson","title":"<code>import IOJSON</code>","text":"<p>Path: <code>mosheh.types.jsoncfg</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.jsoncfg import IOJSON\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#import-defaultjson","title":"<code>import DefaultJSON</code>","text":"<p>Path: <code>mosheh.types.jsoncfg</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.jsoncfg import DefaultJSON\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#import-documentationjson","title":"<code>import DocumentationJSON</code>","text":"<p>Path: <code>mosheh.types.jsoncfg</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.jsoncfg import DocumentationJSON\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#consts","title":"Consts","text":""},{"location":"Codebase/mosheh/commands/create_cmd.py/#root","title":"<code>ROOT</code>","text":"<p>Type: <code>str</code></p> <p>Value: <code>abspath(join(args.json, io_config.get('rootDir', './')))</code></p> Snippet Python<pre><code>ROOT: str = abspath(join(args.json, io_config.get('rootDir', './')))\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#output","title":"<code>OUTPUT</code>","text":"<p>Type: <code>str</code></p> <p>Value: <code>abspath(join(args.json, io_config.get('outputDir', './')))</code></p> Snippet Python<pre><code>OUTPUT: str = abspath(join(args.json, io_config.get('outputDir', './')))\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#proj_name","title":"<code>PROJ_NAME</code>","text":"<p>Type: <code>str</code></p> <p>Value: <code>doc_config.get('projectName', 'PROJECT')</code></p> Snippet Python<pre><code>PROJ_NAME: str = doc_config.get('projectName', 'PROJECT')\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#repo_name","title":"<code>REPO_NAME</code>","text":"<p>Type: <code>str</code></p> <p>Value: <code>doc_config.get('repoName', 'REPO_NAME')</code></p> Snippet Python<pre><code>REPO_NAME: str = doc_config.get('repoName', 'REPO_NAME')\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#repo_url","title":"<code>REPO_URL</code>","text":"<p>Type: <code>str</code></p> <p>Value: <code>doc_config.get('repoUrl', 'REPO_URL')</code></p> Snippet Python<pre><code>REPO_URL: str = doc_config.get('repoUrl', 'REPO_URL')\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#edit_uri","title":"<code>EDIT_URI</code>","text":"<p>Type: <code>str</code></p> <p>Value: <code>doc_config.get('editUri', 'blob/main/documentation/docs')</code></p> Snippet Python<pre><code>EDIT_URI: str = doc_config.get('editUri', 'blob/main/documentation/docs')\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#site_url","title":"<code>SITE_URL</code>","text":"<p>Type: <code>str</code></p> <p>Value: <code>doc_config.get('siteUrl', 'https://lucasgoncsilva.github.io/mosheh')</code></p> Snippet Python<pre><code>SITE_URL: str = doc_config.get('siteUrl', 'https://lucasgoncsilva.github.io/mosheh')\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#logo_path","title":"<code>LOGO_PATH</code>","text":"<p>Type: <code>str | None</code></p> <p>Value: <code>doc_config.get('logoPath')</code></p> Snippet Python<pre><code>LOGO_PATH: str | None = doc_config.get('logoPath')\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#readme_path","title":"<code>README_PATH</code>","text":"<p>Type: <code>str | None</code></p> <p>Value: <code>doc_config.get('readmePath')</code></p> Snippet Python<pre><code>README_PATH: str | None = doc_config.get('readmePath')\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#codebase_nav_path","title":"<code>CODEBASE_NAV_PATH</code>","text":"<p>Type: <code>str</code></p> <p>Value: <code>doc_config.get('codebaseNavPath', 'Codebase')</code></p> Snippet Python<pre><code>CODEBASE_NAV_PATH: str = doc_config.get('codebaseNavPath', 'Codebase')\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#functions","title":"Functions","text":""},{"location":"Codebase/mosheh/commands/create_cmd.py/#def-create","title":"<code>def create</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>args: Namespace</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>None</code></p> Docstring <p>Runs the Mosheh's feature for codebase tracking and documentation creation.</p> <p>While handling the IO and data validation form the <code>mosheh.json</code> config file, which takes the most lines of it's body, once everything is ok, call the proper read-codebase function and then the generate-documentation one.</p> <p>:param args: Namespace object containing the creation information.</p> <p>:type args: argparse.Namespace</p> <p>:return: None</p> <p>:rtype: None</p> Snippet Python<pre><code>def create(args: Namespace) -&gt; None:\n    \"\"\"\n    Runs the Mosheh's feature for codebase tracking and documentation creation.\n\n    While handling the IO and data validation form the `mosheh.json` config file,\n    which takes the most lines of it's body, once everything is ok, call the proper\n    read-codebase function and then the generate-documentation one.\n\n    :param args: Namespace object containing the creation information.\n    :type args: argparse.Namespace\n    :return: None\n    :rtype: None\n    \"\"\"\n    success_json_reading: bool = False\n    doc_config: DocumentationJSON | None = None\n    io_config: IOJSON | None = None\n    try:\n        with open(join(args.json, 'mosheh.json'), encoding='utf-8') as f:\n            json_config: DefaultJSON = loads(f.read())\n        doc_config = DocumentationJSON(**json_config['documentation'])\n        io_config = IOJSON(**json_config['io'])\n        success_json_reading = True\n    except FileNotFoundError:\n        logger.error(f'\"{args.json}\" does not exists as directory')\n    except KeyError:\n        logger.error('\"mosheh.json\" must follow the `init` cmd struct with documentation and io')\n    except Exception as e:\n        logger.critical(f'Not implemented logic for {type(e).__name__}: {e}')\n    if not success_json_reading:\n        return\n    assert io_config and doc_config, 'io_config and doc_config must not be None'\n    ROOT: str = abspath(join(args.json, io_config.get('rootDir', './')))\n    logger.debug(f'JSON \"io.rootDir\" = {ROOT}')\n    OUTPUT: str = abspath(join(args.json, io_config.get('outputDir', './')))\n    logger.debug(f'JSON \"io.outputDir\" = {OUTPUT}')\n    PROJ_NAME: str = doc_config.get('projectName', 'PROJECT')\n    logger.debug(f'JSON \"documentation.projectName\" = {PROJ_NAME}')\n    REPO_NAME: str = doc_config.get('repoName', 'REPO_NAME')\n    logger.debug(f'JSON \"documentation.repoName\" = {REPO_NAME}')\n    REPO_URL: str = doc_config.get('repoUrl', 'REPO_URL')\n    logger.debug(f'JSON \"documentation.repoUrl\" = {REPO_URL}')\n    EDIT_URI: str = doc_config.get('editUri', 'blob/main/documentation/docs')\n    logger.debug(f'JSON \"documentation.editUri\" = {EDIT_URI}')\n    SITE_URL: str = doc_config.get('siteUrl', 'https://lucasgoncsilva.github.io/mosheh')\n    logger.debug(f'JSON \"documentation.siteUrl\" = {SITE_URL}')\n    LOGO_PATH: str | None = doc_config.get('logoPath')\n    logger.debug(f'JSON \"documentation.logoPath\" = {LOGO_PATH}')\n    README_PATH: str | None = doc_config.get('readmePath')\n    logger.debug(f'JSON \"documentation.readmePath\" = {README_PATH}')\n    CODEBASE_NAV_PATH: str = doc_config.get('codebaseNavPath', 'Codebase')\n    logger.debug(f'JSON \"documentation.codebaseNavPath\" = {CODEBASE_NAV_PATH}')\n    logger.info('Arguments parsed successfully')\n    logger.info(f'Starting codebase loading at {ROOT}')\n    data: CodebaseDict = read_codebase(ROOT)\n    logger.info('Codebase successfully loaded')\n    logger.info('Starting final documentation generation')\n    try:\n        create_doc(codebase=data, root=ROOT, proj_name=PROJ_NAME, repo_name=REPO_NAME, repo_url=REPO_URL, edit_uri=EDIT_URI, logo_path=LOGO_PATH, readme_path=README_PATH, output=OUTPUT, codebase_nav_path=CODEBASE_NAV_PATH)\n        logger.info('Documentation created successfully')\n    except CalledProcessError as e:\n        logger.error(e)\n    except FileNotFoundError:\n        logger.error(f'\"{args.json}\" does not exists as directory')\n    except PermissionError:\n        logger.error(f'\"--json\" must be a valid dir and Mosheh must have permission for this, got \"{args.json}\" instead')\n    except Exception as e:\n        logger.critical(f'Not implemented logic for {type(e).__name__}: {e}')\n</code></pre>"},{"location":"Codebase/mosheh/commands/create_cmd.py/#assertions","title":"Assertions","text":""},{"location":"Codebase/mosheh/commands/create_cmd.py/#assert-io_config-and-doc_config","title":"<code>assert io_config and doc_config</code>","text":"<p>Message: <code>'io_config and doc_config must not be None'</code></p> Snippet Python<pre><code>assert io_config and doc_config, 'io_config and doc_config must not be None'\n</code></pre>"},{"location":"Codebase/mosheh/commands/init_cmd.py/","title":"File: <code>init_cmd.py</code>","text":"<p>Role:  Python Source Code</p> <p>Path: <code>mosheh.commands</code></p> <p>Encapsulating the <code>init</code> command logic, this file uses the <code>types.jsoncfg</code> TypedDict classes for ensure the correct structure over the <code>mosheh.json</code> config file generated.</p>"},{"location":"Codebase/mosheh/commands/init_cmd.py/#imports","title":"Imports","text":""},{"location":"Codebase/mosheh/commands/init_cmd.py/#import-namespace","title":"<code>import Namespace</code>","text":"<p>Path: <code>argparse</code></p> <p>Category: native</p> Snippet Python<pre><code>from argparse import Namespace\n</code></pre>"},{"location":"Codebase/mosheh/commands/init_cmd.py/#import-dumps","title":"<code>import dumps</code>","text":"<p>Path: <code>json</code></p> <p>Category: native</p> Snippet Python<pre><code>from json import dumps\n</code></pre>"},{"location":"Codebase/mosheh/commands/init_cmd.py/#import-logger","title":"<code>import Logger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import Logger\n</code></pre>"},{"location":"Codebase/mosheh/commands/init_cmd.py/#import-getlogger","title":"<code>import getLogger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import getLogger\n</code></pre>"},{"location":"Codebase/mosheh/commands/init_cmd.py/#import-abspath","title":"<code>import abspath</code>","text":"<p>Path: <code>os.path</code></p> <p>Category: native</p> Snippet Python<pre><code>from os.path import abspath\n</code></pre>"},{"location":"Codebase/mosheh/commands/init_cmd.py/#import-join","title":"<code>import join</code>","text":"<p>Path: <code>os.path</code></p> <p>Category: native</p> Snippet Python<pre><code>from os.path import join\n</code></pre>"},{"location":"Codebase/mosheh/commands/init_cmd.py/#import-final","title":"<code>import Final</code>","text":"<p>Path: <code>typing</code></p> <p>Category: native</p> Snippet Python<pre><code>from typing import Final\n</code></pre>"},{"location":"Codebase/mosheh/commands/init_cmd.py/#import-iojson","title":"<code>import IOJSON</code>","text":"<p>Path: <code>mosheh.types.jsoncfg</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.jsoncfg import IOJSON\n</code></pre>"},{"location":"Codebase/mosheh/commands/init_cmd.py/#import-defaultjson","title":"<code>import DefaultJSON</code>","text":"<p>Path: <code>mosheh.types.jsoncfg</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.jsoncfg import DefaultJSON\n</code></pre>"},{"location":"Codebase/mosheh/commands/init_cmd.py/#import-documentationjson","title":"<code>import DocumentationJSON</code>","text":"<p>Path: <code>mosheh.types.jsoncfg</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.jsoncfg import DocumentationJSON\n</code></pre>"},{"location":"Codebase/mosheh/commands/init_cmd.py/#consts","title":"Consts","text":""},{"location":"Codebase/mosheh/commands/init_cmd.py/#documentation_json","title":"<code>DOCUMENTATION_JSON</code>","text":"<p>Type: <code>Final[DocumentationJSON]</code></p> <p>Value: <code>DocumentationJSON(projectName='Mosheh', repoName='mosheh', repoUrl='https://github.com/lucasgoncsilva/mosheh', editUri='blob/main/documentation/docs', siteUrl='https://lucasgoncsilva.github.io/mosheh/', logoPath='./path/to/logo.svg', readmePath='./path/to/README.md', codebaseNavPath='Codebase')</code></p> Snippet Python<pre><code>DOCUMENTATION_JSON: Final[DocumentationJSON] = DocumentationJSON(projectName='Mosheh', repoName='mosheh', repoUrl='https://github.com/lucasgoncsilva/mosheh', editUri='blob/main/documentation/docs', siteUrl='https://lucasgoncsilva.github.io/mosheh/', logoPath='./path/to/logo.svg', readmePath='./path/to/README.md', codebaseNavPath='Codebase')\n</code></pre>"},{"location":"Codebase/mosheh/commands/init_cmd.py/#io_json","title":"<code>IO_JSON</code>","text":"<p>Type: <code>Final[IOJSON]</code></p> <p>Value: <code>IOJSON(rootDir='./app/', outputDir='./path/to/output/')</code></p> Snippet Python<pre><code>IO_JSON: Final[IOJSON] = IOJSON(rootDir='./app/', outputDir='./path/to/output/')\n</code></pre>"},{"location":"Codebase/mosheh/commands/init_cmd.py/#default_json","title":"<code>DEFAULT_JSON</code>","text":"<p>Type: <code>Final[DefaultJSON]</code></p> <p>Value: <code>{'documentation': DOCUMENTATION_JSON, 'io': IO_JSON}</code></p> Snippet Python<pre><code>DEFAULT_JSON: Final[DefaultJSON] = {'documentation': DOCUMENTATION_JSON, 'io': IO_JSON}\n</code></pre>"},{"location":"Codebase/mosheh/commands/init_cmd.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"Codebase/mosheh/commands/init_cmd.py/#functions","title":"Functions","text":""},{"location":"Codebase/mosheh/commands/init_cmd.py/#def-init","title":"<code>def init</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>args: Namespace</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>None</code></p> Docstring <p>Creates the <code>mosheh.json</code> config file.</p> <p>By using the <code>types.jsoncfg</code> TypedDict classes for ensure the correct structure over the <code>mosheh.json</code> config file generated, this function incorporates the role of bringing this config file, following the path designited by the own CLI call.</p> <p>:param args: Namespace object containing the creation information.</p> <p>:type args: argparse.Namespace</p> <p>:return: None</p> <p>:rtype: None</p> Snippet Python<pre><code>def init(args: Namespace) -&gt; None:\n    \"\"\"\n    Creates the `mosheh.json` config file.\n\n    By using the `types.jsoncfg` TypedDict classes for ensure the correct structure\n    over the `mosheh.json` config file generated, this function incorporates the role\n    of bringing this config file, following the path designited by the own CLI call.\n\n    :param args: Namespace object containing the creation information.\n    :type args: argparse.Namespace\n    :return: None\n    :rtype: None\n    \"\"\"\n    try:\n        file_path: str = join(args.path, 'mosheh.json')\n        with open(file_path, 'w', encoding='utf-8') as f:\n            f.write(dumps(DEFAULT_JSON, indent=2))\n        logger.info(f'\"mosheh.json\" created at {abspath(file_path)}')\n        logger.debug(f'\"mosheh.json\" = {DEFAULT_JSON}')\n    except FileNotFoundError:\n        logger.error(f'\"{args.path}\" does not exists as directory')\n    except PermissionError:\n        logger.error(f'\"--path\" must be a valid dir and Mosheh must have permission for this, got \"{args.path}\" instead')\n    except Exception as e:\n        logger.critical(f'Not implemented logic for {type(e).__name__}: {e}')\n</code></pre>"},{"location":"Codebase/mosheh/commands/init_cmd.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"Codebase/mosheh/commands/update_cmd.py/","title":"File: <code>update_cmd.py</code>","text":"<p>Role:  Python Source Code</p> <p>Path: <code>mosheh.commands</code></p> <p>Encapsulating the <code>update</code> command logic, this file deals with the most important feature present on Mosheh: to update the codebase documentation.</p> <p>It seems extremely complex, but reading just a few lines shows that here is handled more about the IO and data validation from the <code>mosheh.json</code> config file than the logic implementation itself.</p>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#imports","title":"Imports","text":""},{"location":"Codebase/mosheh/commands/update_cmd.py/#import-namespace","title":"<code>import Namespace</code>","text":"<p>Path: <code>argparse</code></p> <p>Category: native</p> Snippet Python<pre><code>from argparse import Namespace\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#import-loads","title":"<code>import loads</code>","text":"<p>Path: <code>json</code></p> <p>Category: native</p> Snippet Python<pre><code>from json import loads\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#import-logger","title":"<code>import Logger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import Logger\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#import-getlogger","title":"<code>import getLogger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import getLogger\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#import-abspath","title":"<code>import abspath</code>","text":"<p>Path: <code>os.path</code></p> <p>Category: native</p> Snippet Python<pre><code>from os.path import abspath\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#import-join","title":"<code>import join</code>","text":"<p>Path: <code>os.path</code></p> <p>Category: native</p> Snippet Python<pre><code>from os.path import join\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#import-calledprocesserror","title":"<code>import CalledProcessError</code>","text":"<p>Path: <code>subprocess</code></p> <p>Category: native</p> Snippet Python<pre><code>from subprocess import CalledProcessError\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#import-read_codebase","title":"<code>import read_codebase</code>","text":"<p>Path: <code>mosheh.codebase</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.codebase import read_codebase\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#import-update_doc","title":"<code>import update_doc</code>","text":"<p>Path: <code>mosheh.doc.update</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.doc.update import update_doc\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#import-codebasedict","title":"<code>import CodebaseDict</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import CodebaseDict\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#import-iojson","title":"<code>import IOJSON</code>","text":"<p>Path: <code>mosheh.types.jsoncfg</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.jsoncfg import IOJSON\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#import-defaultjson","title":"<code>import DefaultJSON</code>","text":"<p>Path: <code>mosheh.types.jsoncfg</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.jsoncfg import DefaultJSON\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#import-documentationjson","title":"<code>import DocumentationJSON</code>","text":"<p>Path: <code>mosheh.types.jsoncfg</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.jsoncfg import DocumentationJSON\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#consts","title":"Consts","text":""},{"location":"Codebase/mosheh/commands/update_cmd.py/#root","title":"<code>ROOT</code>","text":"<p>Type: <code>str</code></p> <p>Value: <code>abspath(join(args.json, io_config.get('rootDir', './')))</code></p> Snippet Python<pre><code>ROOT: str = abspath(join(args.json, io_config.get('rootDir', './')))\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#output","title":"<code>OUTPUT</code>","text":"<p>Type: <code>str</code></p> <p>Value: <code>abspath(join(args.json, io_config.get('outputDir', './')))</code></p> Snippet Python<pre><code>OUTPUT: str = abspath(join(args.json, io_config.get('outputDir', './')))\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#proj_name","title":"<code>PROJ_NAME</code>","text":"<p>Type: <code>str</code></p> <p>Value: <code>doc_config.get('projectName', 'PROJECT')</code></p> Snippet Python<pre><code>PROJ_NAME: str = doc_config.get('projectName', 'PROJECT')\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#repo_name","title":"<code>REPO_NAME</code>","text":"<p>Type: <code>str</code></p> <p>Value: <code>doc_config.get('repoName', 'REPO_NAME')</code></p> Snippet Python<pre><code>REPO_NAME: str = doc_config.get('repoName', 'REPO_NAME')\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#repo_url","title":"<code>REPO_URL</code>","text":"<p>Type: <code>str</code></p> <p>Value: <code>doc_config.get('repoUrl', 'REPO_URL')</code></p> Snippet Python<pre><code>REPO_URL: str = doc_config.get('repoUrl', 'REPO_URL')\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#edit_uri","title":"<code>EDIT_URI</code>","text":"<p>Type: <code>str</code></p> <p>Value: <code>doc_config.get('editUri', 'blob/main/documentation/docs')</code></p> Snippet Python<pre><code>EDIT_URI: str = doc_config.get('editUri', 'blob/main/documentation/docs')\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#logo_path","title":"<code>LOGO_PATH</code>","text":"<p>Type: <code>str | None</code></p> <p>Value: <code>doc_config.get('logoPath')</code></p> Snippet Python<pre><code>LOGO_PATH: str | None = doc_config.get('logoPath')\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#readme_path","title":"<code>README_PATH</code>","text":"<p>Type: <code>str | None</code></p> <p>Value: <code>doc_config.get('readmePath')</code></p> Snippet Python<pre><code>README_PATH: str | None = doc_config.get('readmePath')\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#codebase_nav_path","title":"<code>CODEBASE_NAV_PATH</code>","text":"<p>Type: <code>str</code></p> <p>Value: <code>doc_config.get('codebaseNavPath', 'Codebase')</code></p> Snippet Python<pre><code>CODEBASE_NAV_PATH: str = doc_config.get('codebaseNavPath', 'Codebase')\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#functions","title":"Functions","text":""},{"location":"Codebase/mosheh/commands/update_cmd.py/#def-update","title":"<code>def update</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>args: Namespace</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>None</code></p> Docstring <p>Runs the Mosheh's feature for codebase tracking and updating.</p> <p>While handling the IO and data validation from the <code>mosheh.json</code> config file, which takes the most lines of it's body, once everything is ok, call the proper read-codebase function and then the generate-documentation one.</p> <p>:param args: Namespace object containing the creation information.</p> <p>:type args: argparse.Namespace</p> <p>:return: None</p> <p>:rtype: None</p> Snippet Python<pre><code>def update(args: Namespace) -&gt; None:\n    \"\"\"\n    Runs the Mosheh's feature for codebase tracking and updating.\n\n    While handling the IO and data validation from the `mosheh.json` config file,\n    which takes the most lines of it's body, once everything is ok, call the proper\n    read-codebase function and then the generate-documentation one.\n\n    :param args: Namespace object containing the creation information.\n    :type args: argparse.Namespace\n    :return: None\n    :rtype: None\n    \"\"\"\n    success_json_reading: bool = False\n    doc_config: DocumentationJSON | None = None\n    io_config: IOJSON | None = None\n    try:\n        with open(join(args.json, 'mosheh.json'), encoding='utf-8') as f:\n            json_config: DefaultJSON = loads(f.read())\n        doc_config = DocumentationJSON(**json_config['documentation'])\n        io_config = IOJSON(**json_config['io'])\n        success_json_reading = True\n    except FileNotFoundError:\n        logger.error(f'\"{args.json}\" does not exists as directory')\n    except KeyError:\n        logger.error('\"mosheh.json\" must follow the `init` cmd struct with documentation and io')\n    except Exception as e:\n        logger.critical(f'Not implemented logic for {type(e).__name__}: {e}')\n    if not success_json_reading:\n        return\n    assert io_config and doc_config, 'io_config and doc_config must not be None'\n    ROOT: str = abspath(join(args.json, io_config.get('rootDir', './')))\n    logger.debug(f'JSON \"io.rootDir\" = {ROOT}')\n    OUTPUT: str = abspath(join(args.json, io_config.get('outputDir', './')))\n    logger.debug(f'JSON \"io.outputDir\" = {OUTPUT}')\n    PROJ_NAME: str = doc_config.get('projectName', 'PROJECT')\n    logger.debug(f'JSON \"documentation.projectName\" = {PROJ_NAME}')\n    REPO_NAME: str = doc_config.get('repoName', 'REPO_NAME')\n    logger.debug(f'JSON \"documentation.repoName\" = {REPO_NAME}')\n    REPO_URL: str = doc_config.get('repoUrl', 'REPO_URL')\n    logger.debug(f'JSON \"documentation.repoUrl\" = {REPO_URL}')\n    EDIT_URI: str = doc_config.get('editUri', 'blob/main/documentation/docs')\n    logger.debug(f'JSON \"documentation.editUri\" = {EDIT_URI}')\n    LOGO_PATH: str | None = doc_config.get('logoPath')\n    logger.debug(f'JSON \"documentation.logoPath\" = {LOGO_PATH}')\n    README_PATH: str | None = doc_config.get('readmePath')\n    logger.debug(f'JSON \"documentation.readmePath\" = {README_PATH}')\n    CODEBASE_NAV_PATH: str = doc_config.get('codebaseNavPath', 'Codebase')\n    logger.debug(f'JSON \"documentation.codebaseNavPath\" = {CODEBASE_NAV_PATH}')\n    logger.info('Arguments parsed successfully')\n    logger.info(f'Starting codebase loading at {ROOT}')\n    data: CodebaseDict = read_codebase(ROOT)\n    logger.info('Codebase successfully loaded')\n    logger.info('Starting final documentation updating')\n    try:\n        update_doc(codebase=data, root=ROOT, readme_path=README_PATH, output=OUTPUT, codebase_nav_path=CODEBASE_NAV_PATH)\n        logger.info('Documentation updated successfully')\n    except CalledProcessError as e:\n        logger.error(e)\n    except FileNotFoundError:\n        logger.error(f'\"{args.json}\" does not exists as directory')\n    except PermissionError:\n        logger.error(f'\"--json\" must be a valid dir and Mosheh must have permission for this, got \"{args.json}\" instead')\n    except Exception as e:\n        logger.critical(f'Not implemented logic for {type(e).__name__}: {e}')\n</code></pre>"},{"location":"Codebase/mosheh/commands/update_cmd.py/#assertions","title":"Assertions","text":""},{"location":"Codebase/mosheh/commands/update_cmd.py/#assert-io_config-and-doc_config","title":"<code>assert io_config and doc_config</code>","text":"<p>Message: <code>'io_config and doc_config must not be None'</code></p> Snippet Python<pre><code>assert io_config and doc_config, 'io_config and doc_config must not be None'\n</code></pre>"},{"location":"Codebase/mosheh/doc/__init__.py/","title":"File: <code>__init__.py</code>","text":"<p>Role:  Python Source Code</p> <p>Path: <code>mosheh.doc</code></p> <p>No file docstring provided.</p>"},{"location":"Codebase/mosheh/doc/__init__.py/#imports","title":"Imports","text":"<p>NO IMPORT DEFINED HERE</p>"},{"location":"Codebase/mosheh/doc/__init__.py/#consts","title":"Consts","text":"<p>NO CONSTANT DEFINED HERE</p>"},{"location":"Codebase/mosheh/doc/__init__.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"Codebase/mosheh/doc/__init__.py/#functions","title":"Functions","text":"<p>NO FUNCTION DEFINED HERE</p>"},{"location":"Codebase/mosheh/doc/__init__.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"Codebase/mosheh/doc/create.py/","title":"File: <code>create.py</code>","text":"<p>Role:  Python Source Code</p> <p>Path: <code>mosheh.doc</code></p> <p>Used to create the output documentation, this file deals with the codebase generated <code>types.basic.CodebaseDict</code> and creates <code>.md</code> files based on its contained information.</p> <p>The only public/exposed function here is <code>create_doc</code>, which takes care of all of the private functions.</p> <p>There\u2019s logic for safely cleaning the codebase, rebuilding the navigation tree, modifying the YAML structure, and copying over the README to serve as homepage, all using internal calls for functions such as <code>process_codebase</code> and <code>get_update_set_nav</code>.</p>"},{"location":"Codebase/mosheh/doc/create.py/#imports","title":"Imports","text":""},{"location":"Codebase/mosheh/doc/create.py/#import-subprocess","title":"<code>import subprocess</code>","text":"<p>Path: <code>None</code></p> <p>Category: native</p> Snippet Python<pre><code>import subprocess\n</code></pre>"},{"location":"Codebase/mosheh/doc/create.py/#import-logger","title":"<code>import Logger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import Logger\n</code></pre>"},{"location":"Codebase/mosheh/doc/create.py/#import-getlogger","title":"<code>import getLogger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import getLogger\n</code></pre>"},{"location":"Codebase/mosheh/doc/create.py/#import-makedirs","title":"<code>import makedirs</code>","text":"<p>Path: <code>os</code></p> <p>Category: native</p> Snippet Python<pre><code>from os import makedirs\n</code></pre>"},{"location":"Codebase/mosheh/doc/create.py/#import-path","title":"<code>import path</code>","text":"<p>Path: <code>os</code></p> <p>Category: native</p> Snippet Python<pre><code>from os import path\n</code></pre>"},{"location":"Codebase/mosheh/doc/create.py/#import-copy2","title":"<code>import copy2</code>","text":"<p>Path: <code>shutil</code></p> <p>Category: native</p> Snippet Python<pre><code>from shutil import copy2\n</code></pre>"},{"location":"Codebase/mosheh/doc/create.py/#import-default_mkdocs_yml","title":"<code>import DEFAULT_MKDOCS_YML</code>","text":"<p>Path: <code>mosheh.constants</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.constants import DEFAULT_MKDOCS_YML\n</code></pre>"},{"location":"Codebase/mosheh/doc/create.py/#import-get_update_set_nav","title":"<code>import get_update_set_nav</code>","text":"<p>Path: <code>mosheh.doc.shared</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.doc.shared import get_update_set_nav\n</code></pre>"},{"location":"Codebase/mosheh/doc/create.py/#import-process_codebase","title":"<code>import process_codebase</code>","text":"<p>Path: <code>mosheh.doc.shared</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.doc.shared import process_codebase\n</code></pre>"},{"location":"Codebase/mosheh/doc/create.py/#import-write_homepage","title":"<code>import write_homepage</code>","text":"<p>Path: <code>mosheh.doc.shared</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.doc.shared import write_homepage\n</code></pre>"},{"location":"Codebase/mosheh/doc/create.py/#import-codebasedict","title":"<code>import CodebaseDict</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import CodebaseDict\n</code></pre>"},{"location":"Codebase/mosheh/doc/create.py/#import-filepath","title":"<code>import FilePath</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import FilePath\n</code></pre>"},{"location":"Codebase/mosheh/doc/create.py/#import-remove_abspath_from_codebase","title":"<code>import remove_abspath_from_codebase</code>","text":"<p>Path: <code>mosheh.utils</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.utils import remove_abspath_from_codebase\n</code></pre>"},{"location":"Codebase/mosheh/doc/create.py/#consts","title":"Consts","text":"<p>NO CONSTANT DEFINED HERE</p>"},{"location":"Codebase/mosheh/doc/create.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"Codebase/mosheh/doc/create.py/#functions","title":"Functions","text":""},{"location":"Codebase/mosheh/doc/create.py/#def-create_doc","title":"<code>def create_doc</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>None</code></p> <p>Kwargs: <code>codebase: CodebaseDict, root: str, output: str, proj_name: str, logo_path: str | None, readme_path: str | None, edit_uri: str = 'blob/main/documentation/docs', repo_name: str = 'GitHub', repo_url: str = 'https://github.com', codebase_nav_path: str = 'Codebase', site_url: str = 'https://lucasgoncsilva.github.io/mosheh'</code></p> <p>Return Type: <code>None</code></p> Docstring <p>Generates a documentation for a Python codebase using MkDocs.</p> <p>This function creates a new MkDocs project at the specified output path, writes a configuration file and processes the provided codebase to generate documentation.</p> <p>Key concepts: - Kwargs: By starting args with \"*\", this function only accepts key-word arguments. - MkDocs: A static site generator that's geared towards project documentation. - Codebase Processing: The function relies on <code>_process_codebase</code> to handle the   codebase structure and populate the documentation content based on Python files   and their stmts. - Configuration: Builds a <code>mkdocs.yml</code> configuration file with project details,   including repository information and editing URI. - Homepage: If <code>readme_path</code> is provided, so the <code>index.md</code> file provided by MkDocs   is overwriten by the <code>README.md</code> found at provided <code>readme_path</code> file.</p> <p>:param codebase: Dict containing nodes representing <code>.py</code> files and their stmts.</p> <p>:type codebase: CodebaseDict</p> <p>:param root: Root dir, where the analysis starts.</p> <p>:type root: str</p> <p>:param output: Path for documentation output, where to be created.</p> <p>:type output: str</p> <p>:param proj_name: The name of the project, for generating MkDocs configuration.</p> <p>:type proj_name: str</p> <p>:param logo_path: Path for doc/project logo, same Material MkDocs's formats.</p> <p>:type logo_path: str | None</p> <p>:param readme_path: The path of the <code>README.md</code> file, to be used as homepage.</p> <p>:type readme_path: str | None</p> <p>:param edit_uri: URI to view raw or edit blob file, default is                     <code>'blob/main/documentation/docs'</code>.</p> <p>:type edit_uri: str</p> <p>:param repo_name: Name of the code repository to be mapped, default is <code>'GitHub'</code>.</p> <p>:type repo_name: str</p> <p>:param repo_url: The URL of the repository, used for linking in the documentation.</p> <p>:type repo_url: str</p> <p>:param codebase_nav_path: Expected codebase nav name to be used/found.</p> <p>:type codebase_nav_path: str = 'Codebase'</p> <p>:param site_url: URL of the documentation website</p> <p>:type site_url: str = 'https://lucasgoncsilva.github.io/mosheh'</p> <p>:return: None</p> <p>:rtype: None</p> Snippet Python<pre><code>def create_doc(*, codebase: CodebaseDict, root: str, output: str, proj_name: str, logo_path: str | None, readme_path: str | None, edit_uri: str='blob/main/documentation/docs', repo_name: str='GitHub', repo_url: str='https://github.com', codebase_nav_path: str='Codebase', site_url: str='https://lucasgoncsilva.github.io/mosheh') -&gt; None:\n    \"\"\"\n    Generates a documentation for a Python codebase using MkDocs.\n\n    This function creates a new MkDocs project at the specified output path, writes a\n    configuration file and processes the provided codebase to generate documentation.\n\n    Key concepts:\n    - Kwargs: By starting args with \"*\", this function only accepts key-word arguments.\n    - MkDocs: A static site generator that's geared towards project documentation.\n    - Codebase Processing: The function relies on `_process_codebase` to handle the\n      codebase structure and populate the documentation content based on Python files\n      and their stmts.\n    - Configuration: Builds a `mkdocs.yml` configuration file with project details,\n      including repository information and editing URI.\n    - Homepage: If `readme_path` is provided, so the `index.md` file provided by MkDocs\n      is overwriten by the `README.md` found at provided `readme_path` file.\n\n    :param codebase: Dict containing nodes representing `.py` files and their stmts.\n    :type codebase: CodebaseDict\n    :param root: Root dir, where the analysis starts.\n    :type root: str\n    :param output: Path for documentation output, where to be created.\n    :type output: str\n    :param proj_name: The name of the project, for generating MkDocs configuration.\n    :type proj_name: str\n    :param logo_path: Path for doc/project logo, same Material MkDocs's formats.\n    :type logo_path: str | None\n    :param readme_path: The path of the `README.md` file, to be used as homepage.\n    :type readme_path: str | None\n    :param edit_uri: URI to view raw or edit blob file, default is\n                        `'blob/main/documentation/docs'`.\n    :type edit_uri: str\n    :param repo_name: Name of the code repository to be mapped, default is `'GitHub'`.\n    :type repo_name: str\n    :param repo_url: The URL of the repository, used for linking in the documentation.\n    :type repo_url: str\n    :param codebase_nav_path: Expected codebase nav name to be used/found.\n    :type codebase_nav_path: str = 'Codebase'\n    :param site_url: URL of the documentation website\n    :type site_url: str = 'https://lucasgoncsilva.github.io/mosheh'\n    :return: None\n    :rtype: None\n    \"\"\"\n    clean_codebase: CodebaseDict = remove_abspath_from_codebase(codebase)\n    output_path: str = path.abspath(output)\n    mkdocs_yml: str = path.join(output_path, 'mkdocs.yml')\n    try:\n        logger.info('Running MkDocs project')\n        result = subprocess.run(['mkdocs', 'new', output_path], check=True, capture_output=True, text=True)\n        logger.debug(f'\\t{result.stdout}' or '\\tNo MkDocs output')\n        logger.info('MkDocs project created')\n    except subprocess.CalledProcessError as e:\n        logger.error(f'Error: {e.stderr}')\n        raise e\n    logger.info('Creating default \"mkdocs.yml\"')\n    _create_default_mkdocs(mkdocs_yml, output, proj_name, logo_path, edit_uri, repo_name, repo_url, codebase_nav_path, site_url)\n    logger.info('Default \"mkdocs.yml\" created')\n    logger.info('Processing codebase')\n    process_codebase(clean_codebase, root, output, codebase_nav_path=codebase_nav_path)\n    logger.info('Codebase processed successfully')\n    logger.info('Getting and updating Nav')\n    get_update_set_nav(mkdocs_yml, clean_codebase, codebase_nav_path)\n    logger.debug('\\tNav addeded to mkdocs.yml')\n    if readme_path:\n        write_homepage(output_path, readme_path)\n</code></pre>"},{"location":"Codebase/mosheh/doc/create.py/#def-_create_default_mkdocs","title":"<code>def _create_default_mkdocs</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>mkdocs_yml: FilePath, output: str, proj_name: str, logo_path: str | None, edit_uri: str, repo_name: str, repo_url: str, codebase_nav_path: str, site_url: str</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>None</code></p> Docstring <p>No docstring provided.</p> Snippet Python<pre><code>def _create_default_mkdocs(mkdocs_yml: FilePath, output: str, proj_name: str, logo_path: str | None, edit_uri: str='blob/main/documentation/docs', repo_name: str='GitHub', repo_url: str='https://github.com', codebase_nav_path: str='Codebase', site_url: str='https://lucasgoncsilva.github.io/mosheh') -&gt; None:\n    with open(mkdocs_yml, 'w', encoding='utf-8') as f:\n        f.write(_default_doc_config(proj_name=proj_name, output=output, logo_path=logo_path, edit_uri=edit_uri, repo_name=repo_name, repo_url=repo_url, codebase_nav_path=codebase_nav_path, site_url=site_url))\n</code></pre>"},{"location":"Codebase/mosheh/doc/create.py/#def-_default_doc_config","title":"<code>def _default_doc_config</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>None</code></p> <p>Kwargs: <code>proj_name: str, output: str, logo_path: str | None, edit_uri: str = 'blob/main/documentation/docs', site_url: str = 'https://lucasgoncsilva.github.io/mosheh', repo_name: str = 'GitHub', repo_url: str = 'https://github.com/', codebase_nav_path: str = 'Codebase'</code></p> <p>Return Type: <code>str</code></p> Docstring <p>Generates the default configuration for an MkDocs documentation project.</p> <p>This function creates an <code>mkdocs.yml</code> configuration file with project details, repository information, and an optional logo. If a logo is provided, it is copied to the documentation's image directory.</p> <p>Key features: - Supports setting project and repository information. - Handles optional logos and ensures they are placed in the correct directory. - Returns a formatted YAML configuration as a string.</p> <p>:param proj_name: The name of the project, for generating MkDocs configuration.</p> <p>:type proj_name: str</p> <p>:param output: Path for documentation output, where to be created.</p> <p>:type output: str</p> <p>:param logo_path: Path for doc/project logo, same Material MkDocs's formats.</p> <p>:type logo_path: str | None</p> <p>:param edit_uri: URI to view raw or edit blob file, default is                     <code>'blob/main/documentation/docs'</code>.</p> <p>:type edit_uri: str</p> <p>:param repo_name: Name of the code repository to be mapped, default is <code>'GitHub'</code>.</p> <p>:type repo_name: str</p> <p>:param site_url: URL of the documentation website</p> <p>:type site_url: str = 'https://lucasgoncsilva.github.io/mosheh'</p> <p>:param repo_url: The URL of the repository, used for linking in the documentation.</p> <p>:type repo_url: str</p> <p>:return: Formatted MkDocs YAML configuration.</p> <p>:rtype: str</p> Snippet Python<pre><code>def _default_doc_config(*, proj_name: str, output: str, logo_path: str | None, edit_uri: str='blob/main/documentation/docs', site_url: str='https://lucasgoncsilva.github.io/mosheh', repo_name: str='GitHub', repo_url: str='https://github.com/', codebase_nav_path: str='Codebase') -&gt; str:\n    \"\"\"\n    Generates the default configuration for an MkDocs documentation project.\n\n    This function creates an `mkdocs.yml` configuration file with project details,\n    repository information, and an optional logo. If a logo is provided, it is copied\n    to the documentation's image directory.\n\n    Key features:\n    - Supports setting project and repository information.\n    - Handles optional logos and ensures they are placed in the correct directory.\n    - Returns a formatted YAML configuration as a string.\n\n    :param proj_name: The name of the project, for generating MkDocs configuration.\n    :type proj_name: str\n    :param output: Path for documentation output, where to be created.\n    :type output: str\n    :param logo_path: Path for doc/project logo, same Material MkDocs's formats.\n    :type logo_path: str | None\n    :param edit_uri: URI to view raw or edit blob file, default is\n                        `'blob/main/documentation/docs'`.\n    :type edit_uri: str\n    :param repo_name: Name of the code repository to be mapped, default is `'GitHub'`.\n    :type repo_name: str\n    :param site_url: URL of the documentation website\n    :type site_url: str = 'https://lucasgoncsilva.github.io/mosheh'\n    :param repo_url: The URL of the repository, used for linking in the documentation.\n    :type repo_url: str\n    :return: Formatted MkDocs YAML configuration.\n    :rtype: str\n    \"\"\"\n    new_logo_path: str\n    if logo_path:\n        extension: str = path.splitext(logo_path)[-1]\n        logo_file_path: str = path.join(output, 'docs', 'img')\n        file_name: str = path.join(logo_file_path, f'logo{extension}')\n        logger.debug('Logo path handling done')\n        if not path.exists(logo_file_path):\n            makedirs(logo_file_path)\n            logger.debug(f'{logo_file_path} logo file path created')\n        copy2(logo_path, file_name)\n        logger.info(f'{logo_path} copied to {file_name}')\n        new_logo_path = file_name.removeprefix(path.join(output, 'docs', ''))\n    else:\n        new_logo_path = 'https://squidfunk.github.io/mkdocs-material/assets/favicon.png'\n    return DEFAULT_MKDOCS_YML.format(proj_name=proj_name, site_url=site_url, edit_uri=edit_uri, repo_name=repo_name, repo_url=repo_url, logo_path=new_logo_path, codebase_nav_path=codebase_nav_path)\n</code></pre>"},{"location":"Codebase/mosheh/doc/create.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"Codebase/mosheh/doc/shared.py/","title":"File: <code>shared.py</code>","text":"<p>Role:  Python Source Code</p> <p>Path: <code>mosheh.doc</code></p> <p>Containing the logic and functions shared between the commands, more specifically the logic and functions related to documentation creation/updating.</p> <p>Two main functions are defined and exported here:</p> <ul> <li><code>process_codebase</code>: Recursively processes a codebase and generates documentation for     each file.</li> <li><code>get_update_set_nav</code>: Sets the <code>mkdocs.yml</code> Nav \"Codebase\" section to the current     state, updating it.</li> </ul> <p>Every other function is a private/internal one, being called only for the other ones from this same file; this is to keep the logic in the same space, while keeping the code base less confusing.</p>"},{"location":"Codebase/mosheh/doc/shared.py/#imports","title":"Imports","text":""},{"location":"Codebase/mosheh/doc/shared.py/#import-logger","title":"<code>import Logger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import Logger\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-getlogger","title":"<code>import getLogger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import getLogger\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-makedirs","title":"<code>import makedirs</code>","text":"<p>Path: <code>os</code></p> <p>Category: native</p> Snippet Python<pre><code>from os import makedirs\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-path","title":"<code>import path</code>","text":"<p>Path: <code>os</code></p> <p>Category: native</p> Snippet Python<pre><code>from os import path\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-sep","title":"<code>import sep</code>","text":"<p>Path: <code>os</code></p> <p>Category: native</p> Snippet Python<pre><code>from os import sep\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-any","title":"<code>import Any</code>","text":"<p>Path: <code>typing</code></p> <p>Category: native</p> Snippet Python<pre><code>from typing import Any\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-cast","title":"<code>import cast</code>","text":"<p>Path: <code>typing</code></p> <p>Category: native</p> Snippet Python<pre><code>from typing import cast\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-cdumper","title":"<code>import CDumper</code>","text":"<p>Path: <code>yaml</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from yaml import CDumper\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-cloader","title":"<code>import CLoader</code>","text":"<p>Path: <code>yaml</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from yaml import CLoader\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-dump","title":"<code>import dump</code>","text":"<p>Path: <code>yaml</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from yaml import dump\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-load","title":"<code>import load</code>","text":"<p>Path: <code>yaml</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from yaml import load\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-assert_md_struct","title":"<code>import ASSERT_MD_STRUCT</code>","text":"<p>Path: <code>mosheh.constants</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.constants import ASSERT_MD_STRUCT\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-assign_md_struct","title":"<code>import ASSIGN_MD_STRUCT</code>","text":"<p>Path: <code>mosheh.constants</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.constants import ASSIGN_MD_STRUCT\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-class_def_md_struct","title":"<code>import CLASS_DEF_MD_STRUCT</code>","text":"<p>Path: <code>mosheh.constants</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.constants import CLASS_DEF_MD_STRUCT\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-file_markdown","title":"<code>import FILE_MARKDOWN</code>","text":"<p>Path: <code>mosheh.constants</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.constants import FILE_MARKDOWN\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-function_def_md_struct","title":"<code>import FUNCTION_DEF_MD_STRUCT</code>","text":"<p>Path: <code>mosheh.constants</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.constants import FUNCTION_DEF_MD_STRUCT\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-import_md_struct","title":"<code>import IMPORT_MD_STRUCT</code>","text":"<p>Path: <code>mosheh.constants</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.constants import IMPORT_MD_STRUCT\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-annotation","title":"<code>import Annotation</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Annotation\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-args","title":"<code>import Args</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Args\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-assertionmessage","title":"<code>import AssertionMessage</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import AssertionMessage\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-assertiontest","title":"<code>import AssertionTest</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import AssertionTest\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-codesnippet","title":"<code>import CodeSnippet</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import CodeSnippet\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-codebasedict","title":"<code>import CodebaseDict</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import CodebaseDict\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-decorator","title":"<code>import Decorator</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Decorator\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-docstring","title":"<code>import Docstring</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Docstring\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-filepath","title":"<code>import FilePath</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import FilePath\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-importedidentifier","title":"<code>import ImportedIdentifier</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import ImportedIdentifier\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-inheritance","title":"<code>import Inheritance</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Inheritance\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-kwargs","title":"<code>import Kwargs</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Kwargs\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-modulename","title":"<code>import ModuleName</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import ModuleName\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-modulepath","title":"<code>import ModulePath</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import ModulePath\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-standardreturn","title":"<code>import StandardReturn</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import StandardReturn\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-token","title":"<code>import Token</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Token\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-value","title":"<code>import Value</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Value\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-filerole","title":"<code>import FileRole</code>","text":"<p>Path: <code>mosheh.types.enums</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.enums import FileRole\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-functiontype","title":"<code>import FunctionType</code>","text":"<p>Path: <code>mosheh.types.enums</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.enums import FunctionType\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-importtype","title":"<code>import ImportType</code>","text":"<p>Path: <code>mosheh.types.enums</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.enums import ImportType\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-statement","title":"<code>import Statement</code>","text":"<p>Path: <code>mosheh.types.enums</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.enums import Statement\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-build_nav_struct","title":"<code>import build_nav_struct</code>","text":"<p>Path: <code>mosheh.utils</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.utils import build_nav_struct\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#import-indent_code","title":"<code>import indent_code</code>","text":"<p>Path: <code>mosheh.utils</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.utils import indent_code\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#consts","title":"Consts","text":"<p>NO CONSTANT DEFINED HERE</p>"},{"location":"Codebase/mosheh/doc/shared.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"Codebase/mosheh/doc/shared.py/#functions","title":"Functions","text":""},{"location":"Codebase/mosheh/doc/shared.py/#def-process_codebase","title":"<code>def process_codebase</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>codebase: dict[str, CodebaseDict] | dict[str, list[StandardReturn]], root: str, exit: str, basedir: str, codebase_nav_path: str</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>None</code></p> Docstring <p>Recursively processes a codebase and generates documentation for each file.</p> <p>This function traverses a codebase structure, processes each file's statements and generates corresponding Markdown documentation. The documentation is written to the specified output directory. If some file contains nested dictionaries, the function recursively processes each nested level.</p> <p>Key concepts: - Recursive Processing: Handles both individual and nested dirs and files. - File Documentation: Converts statements into documentation and writes to a common     standardized structure. - Directory Structure: Preserves directory structure in the output documentation.</p> <p>Example:</p> Python<pre><code>process_codebase(codebase, '/root', '/output')\n# Processes the codebase and generates documentation in the '/output' directory.\n</code></pre> <p>:param codebase: The codebase to process, which can contain files or nested dirs.</p> <p>:type codebase: dict[str, CodebaseDict] | dict[str, list[StandardReturn]]</p> <p>:param root: The root directory of the project.</p> <p>:type root: str</p> <p>:param exit: The output directory where documentation will be saved.</p> <p>:type exit: str</p> <p>:param basedir: The base directory used during the recursive traversal.</p> <p>:type basedir: str = ''</p> <p>:param codebase_nav_path: Expected codebase nav name to be used/found.</p> <p>:type codebase_nav_path: str = 'Codebase'</p> <p>:return: None</p> <p>:rtype: None</p> Snippet Python<pre><code>def process_codebase(codebase: dict[str, CodebaseDict] | dict[str, list[StandardReturn]], root: str, exit: str, basedir: str='', codebase_nav_path: str='Codebase') -&gt; None:\n    \"\"\"\n    Recursively processes a codebase and generates documentation for each file.\n\n    This function traverses a codebase structure, processes each file's statements\n    and generates corresponding Markdown documentation. The documentation is written\n    to the specified output directory. If some file contains nested dictionaries,\n    the function recursively processes each nested level.\n\n    Key concepts:\n    - Recursive Processing: Handles both individual and nested dirs and files.\n    - File Documentation: Converts statements into documentation and writes to a common\n        standardized structure.\n    - Directory Structure: Preserves directory structure in the output documentation.\n\n    Example:\n\n    ```python\n    process_codebase(codebase, '/root', '/output')\n    # Processes the codebase and generates documentation in the '/output' directory.\n    ```\n\n    :param codebase: The codebase to process, which can contain files or nested dirs.\n    :type codebase: dict[str, CodebaseDict] | dict[str, list[StandardReturn]]\n    :param root: The root directory of the project.\n    :type root: str\n    :param exit: The output directory where documentation will be saved.\n    :type exit: str\n    :param basedir: The base directory used during the recursive traversal.\n    :type basedir: str = ''\n    :param codebase_nav_path: Expected codebase nav name to be used/found.\n    :type codebase_nav_path: str = 'Codebase'\n    :return: None\n    :rtype: None\n    \"\"\"\n    parents: list[str] = list(codebase.keys())\n    docs_path: FilePath = path.join(exit, 'docs')\n    for key in parents:\n        value = codebase[key]\n        new_path: str = path.join(basedir, key)\n        if isinstance(value, list):\n            logger.debug(f\"\\tEvaluating file '{key}' of {parents}\")\n            _process_file(key, value, new_path, root, docs_path, codebase_nav_path=codebase_nav_path)\n        else:\n            logger.debug(f\"\\tReprocessing dir '{key}' of {parents}\")\n            process_codebase(value, root, exit, new_path)\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#def-_process_file","title":"<code>def _process_file</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>key: str, stmts: list[StandardReturn], file_path: FilePath, root: str, docs_path: FilePath, codebase_nav_path: str</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>None</code></p> Docstring <p>Processes a file's stmts and generates it's corresponding documentation.</p> <p>Converts a list of stmts into a Markdown document, writes the content to the appropriate file path, and updates the navigation structure for the documentation. If the necessary folder path does not exist, it is created.</p> <p>Key concepts: - Statement Processing: Converts stmts into Markdown format. - File Writing: Saves the generated content to the appropriate file. - Navigation Update: Updates the documentation's navigation structure.</p> <p>Example:</p> Python<pre><code>_process_file('module_name', stmts, 'src/module.py', '/root', '/docs')\n# Processes the stmts from 'module.py' and generates corresponding markdown docs.\n</code></pre> <p>:param key: The key representing the module or file being processed.</p> <p>:type key: str</p> <p>:param stmts: The list of stmts that represent the code to be documented.</p> <p>:type stmts: list[StandardReturn]</p> <p>:param file_path: The path to the source file, used to derive output locations.</p> <p>:type file_path: str</p> <p>:param root: The root directory of the project.</p> <p>:type root: str</p> <p>:param docs_path: The path to the documentation directory.</p> <p>:type docs_path: str</p> <p>:param codebase_nav_path: Expected codebase nav name to be used/found.</p> <p>:type codebase_nav_path: str = 'Codebase'</p> <p>:return: None</p> <p>:rtype: None</p> Snippet Python<pre><code>def _process_file(key: str, stmts: list[StandardReturn], file_path: FilePath, root: str, docs_path: FilePath, codebase_nav_path: str='Codebase') -&gt; None:\n    \"\"\"\n    Processes a file's stmts and generates it's corresponding documentation.\n\n    Converts a list of stmts into a Markdown document, writes the content to\n    the appropriate file path, and updates the navigation structure for the\n    documentation. If the necessary folder path does not exist, it is created.\n\n    Key concepts:\n    - Statement Processing: Converts stmts into Markdown format.\n    - File Writing: Saves the generated content to the appropriate file.\n    - Navigation Update: Updates the documentation's navigation structure.\n\n    Example:\n\n    ```python\n    _process_file('module_name', stmts, 'src/module.py', '/root', '/docs')\n    # Processes the stmts from 'module.py' and generates corresponding markdown docs.\n    ```\n\n    :param key: The key representing the module or file being processed.\n    :type key: str\n    :param stmts: The list of stmts that represent the code to be documented.\n    :type stmts: list[StandardReturn]\n    :param file_path: The path to the source file, used to derive output locations.\n    :type file_path: str\n    :param root: The root directory of the project.\n    :type root: str\n    :param docs_path: The path to the documentation directory.\n    :type docs_path: str\n    :param codebase_nav_path: Expected codebase nav name to be used/found.\n    :type codebase_nav_path: str = 'Codebase'\n    :return: None\n    :rtype: None\n    \"\"\"\n    if not stmts:\n        logger.debug(f'\\t\\t{key} empty, has no statement')\n        return\n    content: str = _codebase_to_markdown(stmts, file_path)\n    output_file_path: FilePath = path.join(docs_path, codebase_nav_path, file_path.removeprefix(root) + '.md')\n    folder_path: FilePath = path.dirname(output_file_path)\n    if not path.exists(path.join('.', folder_path)):\n        makedirs(path.join('.', folder_path))\n        logger.debug(f'\\t\\tCreated path \"{folder_path}\"')\n    _write_to_file(output_file_path, content)\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#def-_codebase_to_markdown","title":"<code>def _codebase_to_markdown</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>file_data: list[StandardReturn], basedir: str</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>str</code></p> Docstring <p>Converts a file's processed data into a structured Markdown representation.</p> <p>This function processes a list of stmts extracted from a Python file and generates a Markdown-formatted string. It categorizes stmts into imports, constants, classes, functions, and assertions, ensuring that each type is documented appropriately. If a category has no stmts, a default informational message is added.</p> <p>Key concepts: - Statement Handling: The function processes different types of stmts     (imports, assignments, class and function definitions, etc.) and organizes     them into corresponding sections. - Markdown Generation: The output is formatted using a predefined Markdown     template (<code>FILE_MARKDOWN</code>) that structures the documentation by category. - Category Defaults: If no stmts exist for a particular category, an     informational block is added to indicate it's absence.</p> <p>Example:</p> Python<pre><code>file_data: list[StandardReturn] = [\n    {'statement': Statement.Import, 'name': 'os', ...},\n    {'statement': Statement.ClassDef, 'name': 'MyClass', ...},\n]\n_codebase_to_markdown(file_data, '/path/to/module/file.py')\n# Outputs a Markdown string with sections for imports and classes\n</code></pre> <p>:param file_data: A list of statement dict for the parsed contents of a Python file.</p> <p>:type file_data: list[StandardReturn]</p> <p>:param basedir: The file in-process' base dir, used to generate the module path.</p> <p>:type basedir: str</p> <p>:return: A Markdown-formatted string documenting the contents of the file.</p> <p>:rtype: str</p> Snippet Python<pre><code>def _codebase_to_markdown(file_data: list[StandardReturn], basedir: str) -&gt; str:\n    \"\"\"\n    Converts a file's processed data into a structured Markdown representation.\n\n    This function processes a list of stmts extracted from a Python file and\n    generates a Markdown-formatted string. It categorizes stmts into imports,\n    constants, classes, functions, and assertions, ensuring that each type is\n    documented appropriately. If a category has no stmts, a default informational\n    message is added.\n\n    Key concepts:\n    - Statement Handling: The function processes different types of stmts\n        (imports, assignments, class and function definitions, etc.) and organizes\n        them into corresponding sections.\n    - Markdown Generation: The output is formatted using a predefined Markdown\n        template (`FILE_MARKDOWN`) that structures the documentation by category.\n    - Category Defaults: If no stmts exist for a particular category, an\n        informational block is added to indicate it's absence.\n\n    Example:\n\n    ```python\n    file_data: list[StandardReturn] = [\n        {'statement': Statement.Import, 'name': 'os', ...},\n        {'statement': Statement.ClassDef, 'name': 'MyClass', ...},\n    ]\n    _codebase_to_markdown(file_data, '/path/to/module/file.py')\n    # Outputs a Markdown string with sections for imports and classes\n    ```\n\n    :param file_data: A list of statement dict for the parsed contents of a Python file.\n    :type file_data: list[StandardReturn]\n    :param basedir: The file in-process' base dir, used to generate the module path.\n    :type basedir: str\n    :return: A Markdown-formatted string documenting the contents of the file.\n    :rtype: str\n    \"\"\"\n    __meta__: StandardReturn = file_data.pop(0)\n    filename: str = basedir.split(path.sep)[-1]\n    role: str = cast(FileRole, __meta__.get('__role__')).value\n    file_path: str = basedir.removesuffix(filename).replace(path.sep, '.').removeprefix('..').removeprefix('.').removesuffix('.')\n    filedoc: str = cast(str, __meta__.get('__docstring__'))\n    imports: str = ''\n    constants: str = ''\n    classes: str = ''\n    functions: str = ''\n    assertions: str = ''\n    logger.debug(f'\\t\\t\\tFile: {basedir}')\n    for stmt in file_data:\n        match stmt['statement']:\n            case Statement.Import:\n                imports += _handle_import(stmt)\n            case Statement.ImportFrom:\n                imports += _handle_import_from(stmt)\n            case Statement.Assign:\n                constants += _handle_assign(stmt)\n            case Statement.AnnAssign:\n                constants += _handle_annassign(stmt)\n            case Statement.ClassDef:\n                classes += _handle_class_def(stmt)\n            case Statement.FunctionDef | Statement.AsyncFunctionDef:\n                functions += _handle_function_def(stmt)\n            case Statement.Assert:\n                assertions += _handle_assert(stmt)\n            case _:\n                logger.error(f\"Statement shoud not be processed here: {stmt['statement']}\")\n    if not imports:\n        logger.debug('\\t\\t\\tNo imports defined here')\n        imports = '!!! info \"NO IMPORT DEFINED HERE\"'\n    if not constants:\n        logger.debug('\\t\\t\\tNo constants defined here')\n        constants = '!!! info \"NO CONSTANT DEFINED HERE\"'\n    if not classes:\n        logger.debug('\\t\\t\\tNo classes defined here')\n        classes = '!!! info \"NO CLASS DEFINED HERE\"'\n    if not functions:\n        logger.debug('\\t\\t\\tNo functions defined here')\n        functions = '!!! info \"NO FUNCTION DEFINED HERE\"'\n    if not assertions:\n        logger.debug('\\t\\t\\tNo assertions defined here')\n        assertions = '!!! info \"NO ASSERT DEFINED HERE\"'\n    return FILE_MARKDOWN.format(filename=filename, role=role, file_path=file_path, filedoc=filedoc, imports=imports, constants=constants, classes=classes, functions=functions, assertions=assertions)\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#def-_write_to_file","title":"<code>def _write_to_file</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>file_path: FilePath, content: str</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>None</code></p> Docstring <p>Writes content to a specified file.</p> <p>This function opens a file at the given path in write mode and writes the provided content to it. The content is written using UTF-8 encoding, ensuring compatibility with various char sets.</p> <p>Key concepts: - File Writing: Opens a file for writing and writes the content. - UTF-8 Encoding: Ensures the file is written with UTF-8 for proper char handling.</p> <p>Example:</p> Python<pre><code>_write_to_file('output.md', 'This is some content.')\n# Writes the content \"This is some content.\" to 'output.md'.\n</code></pre> <p>:param file_path: The path to the file where the content will be written.</p> <p>:type file_path: FilePath</p> <p>:param content: The content to be written to the file.</p> <p>:type content: str</p> <p>:return: None</p> <p>:rtype: None</p> Snippet Python<pre><code>def _write_to_file(file_path: FilePath, content: str) -&gt; None:\n    \"\"\"\n    Writes content to a specified file.\n\n    This function opens a file at the given path in write mode and writes the provided\n    content to it. The content is written using UTF-8 encoding, ensuring compatibility\n    with various char sets.\n\n    Key concepts:\n    - File Writing: Opens a file for writing and writes the content.\n    - UTF-8 Encoding: Ensures the file is written with UTF-8 for proper char handling.\n\n    Example:\n\n    ```python\n    _write_to_file('output.md', 'This is some content.')\n    # Writes the content \"This is some content.\" to 'output.md'.\n    ```\n\n    :param file_path: The path to the file where the content will be written.\n    :type file_path: FilePath\n    :param content: The content to be written to the file.\n    :type content: str\n    :return: None\n    :rtype: None\n    \"\"\"\n    with open(path.join('.', file_path), 'w', encoding='utf-8') as file:\n        file.write(content)\n        logger.debug(f'\\t\\t\\tContent written to \"{file_path.split(sep)[-1]}\"')\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#def-_handle_import","title":"<code>def _handle_import</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>stmt: StandardReturn</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>str</code></p> Docstring <p>Generates a Markdown representation for an <code>import</code> statement.</p> <p>This function processes an <code>import ...</code> statement from a parsed Python file, formatting it into a structured Markdown block. The output includes the import name, category and the indented code snippet.</p> <p>Key concepts: - Import Handling: Extracts the import statement's details (name, category, code)     and formats them for documentation. - Indentation: The <code>indent_code</code> function is used to apply consistent indentation     to the statement code before including it in the Markdown output. - MD Struct: The output Markdown uses a predefined template - <code>IMPORT_MD_STRUCT</code>.</p> <p>Example:</p> Python<pre><code>stmt: StandardReturn = {\n    'statement': Statement.Import,\n    'name': 'os',\n    'category': ImportType.Native,\n    'code': 'import os',\n}\nhandle_import(stmt)\n# Outputs a formatted Markdown string representing the import\n</code></pre> <p>:param stmt: A dict containing the details of the import statement.</p> <p>:type stmt: StandardReturn</p> <p>:return: A formatted Markdown string documenting the import statement.</p> <p>:rtype: str</p> Snippet Python<pre><code>def _handle_import(stmt: StandardReturn) -&gt; str:\n    \"\"\"\n    Generates a Markdown representation for an `import` statement.\n\n    This function processes an `import ...` statement from a parsed Python file,\n    formatting it into a structured Markdown block. The output includes the import\n    name, category and the indented code snippet.\n\n    Key concepts:\n    - Import Handling: Extracts the import statement's details (name, category, code)\n        and formats them for documentation.\n    - Indentation: The `indent_code` function is used to apply consistent indentation\n        to the statement code before including it in the Markdown output.\n    - MD Struct: The output Markdown uses a predefined template - `IMPORT_MD_STRUCT`.\n\n    Example:\n\n    ```python\n    stmt: StandardReturn = {\n        'statement': Statement.Import,\n        'name': 'os',\n        'category': ImportType.Native,\n        'code': 'import os',\n    }\n    handle_import(stmt)\n    # Outputs a formatted Markdown string representing the import\n    ```\n\n    :param stmt: A dict containing the details of the import statement.\n    :type stmt: StandardReturn\n    :return: A formatted Markdown string documenting the import statement.\n    :rtype: str\n    \"\"\"\n    name: ModuleName = cast(ModuleName, stmt['name'])\n    category: ImportType = cast(ImportType, stmt['category'])\n    code: CodeSnippet = indent_code(cast(CodeSnippet, stmt['code']))\n    return IMPORT_MD_STRUCT.format(name=name, _path=None, category=category.value, code=code)\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#def-_handle_import_from","title":"<code>def _handle_import_from</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>stmt: StandardReturn</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>str</code></p> Docstring <p>Generates a Markdown representation for an <code>import</code> statement.</p> <p>This function processes a <code>from ... import ...</code> statement from a parsed Python file, formatting it into a structured Markdown block. The output includes the import name, category and the indented code snippet.</p> <p>Key concepts: - Import Handling: Extracts the import statement's details (name, category, code)     and formats them for documentation. - Indentation: The <code>indent_code</code> function is used to apply consistent indentation     to the statement code before including it in the Markdown output. - MD Struct: The output Markdown uses a predefined template - <code>IMPORT_MD_STRUCT</code>.</p> <p>Example:</p> Python<pre><code>stmt: StandardReturn = {\n    'statement': Statement.ImportFrom,\n    'name': 'environ',\n    'category': ImportType.Native,\n    'code': 'from os import environ',\n}\nhandle_import(stmt)\n# Outputs a formatted Markdown string representing the import\n</code></pre> <p>:param stmt: A dict containing the details of the import statement.</p> <p>:type stmt: StandardReturn</p> <p>:return: A formatted Markdown string documenting the import statement.</p> <p>:rtype: str</p> Snippet Python<pre><code>def _handle_import_from(stmt: StandardReturn) -&gt; str:\n    \"\"\"\n    Generates a Markdown representation for an `import` statement.\n\n    This function processes a `from ... import ...` statement from a parsed Python\n    file, formatting it into a structured Markdown block. The output includes the\n    import name, category and the indented code snippet.\n\n    Key concepts:\n    - Import Handling: Extracts the import statement's details (name, category, code)\n        and formats them for documentation.\n    - Indentation: The `indent_code` function is used to apply consistent indentation\n        to the statement code before including it in the Markdown output.\n    - MD Struct: The output Markdown uses a predefined template - `IMPORT_MD_STRUCT`.\n\n    Example:\n\n    ```python\n    stmt: StandardReturn = {\n        'statement': Statement.ImportFrom,\n        'name': 'environ',\n        'category': ImportType.Native,\n        'code': 'from os import environ',\n    }\n    handle_import(stmt)\n    # Outputs a formatted Markdown string representing the import\n    ```\n\n    :param stmt: A dict containing the details of the import statement.\n    :type stmt: StandardReturn\n    :return: A formatted Markdown string documenting the import statement.\n    :rtype: str\n    \"\"\"\n    name: ImportedIdentifier = cast(ImportedIdentifier, stmt['name'])\n    _path: ModulePath = cast(ModulePath, stmt['path'])\n    category: ImportType = cast(ImportType, stmt['category'])\n    code: CodeSnippet = indent_code(f'from {_path} import {name}')\n    return IMPORT_MD_STRUCT.format(name=name, _path=_path, category=category.value, code=code)\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#def-_handle_assign","title":"<code>def _handle_assign</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>stmt: StandardReturn</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>str</code></p> Docstring <p>Generates a Markdown representation for an <code>assign</code> statement.</p> <p>This function processes a <code>token = value</code> statement from a parsed Python file, formatting it into a structured Markdown block. The output includes the assign tokens, value and the indented code snippet.</p> <p>Key concepts: - Assign Handling: Extracts the assign statement's details (tokens, value, code)     and formats them for documentation. - Indentation: The <code>indent_code</code> function is used to apply consistent indentation     to the statement code before including it in the Markdown output. - MD Struct: The output Markdown uses a predefined template - <code>ASSIGN_MD_STRUCT</code>.</p> <p>Example:</p> Python<pre><code>stmt: StandardReturn = {\n    'statement': Statement.Assign,\n    'tokens': ['foo', 'bar'],\n    'value': '(True, False)',\n    'code': 'foo, bar = True, False',\n}\nhandle_assign(stmt)\n# Outputs a formatted Markdown string representing the assign\n</code></pre> <p>:param stmt: A dict containing the details of the assign statement.</p> <p>:type stmt: StandardReturn</p> <p>:return: A formatted Markdown string documenting the assign statement.</p> <p>:rtype: str</p> Snippet Python<pre><code>def _handle_assign(stmt: StandardReturn) -&gt; str:\n    \"\"\"\n    Generates a Markdown representation for an `assign` statement.\n\n    This function processes a `token = value` statement from a parsed Python file,\n    formatting it into a structured Markdown block. The output includes the assign\n    tokens, value and the indented code snippet.\n\n    Key concepts:\n    - Assign Handling: Extracts the assign statement's details (tokens, value, code)\n        and formats them for documentation.\n    - Indentation: The `indent_code` function is used to apply consistent indentation\n        to the statement code before including it in the Markdown output.\n    - MD Struct: The output Markdown uses a predefined template - `ASSIGN_MD_STRUCT`.\n\n    Example:\n\n    ```python\n    stmt: StandardReturn = {\n        'statement': Statement.Assign,\n        'tokens': ['foo', 'bar'],\n        'value': '(True, False)',\n        'code': 'foo, bar = True, False',\n    }\n    handle_assign(stmt)\n    # Outputs a formatted Markdown string representing the assign\n    ```\n\n    :param stmt: A dict containing the details of the assign statement.\n    :type stmt: StandardReturn\n    :return: A formatted Markdown string documenting the assign statement.\n    :rtype: str\n    \"\"\"\n    tokens: Token = ', '.join(cast(list[Token], stmt['tokens']))\n    value: Value = cast(Value, stmt['value'])\n    code: CodeSnippet = indent_code(cast(str, stmt['code']))\n    return ASSIGN_MD_STRUCT.format(token=tokens, _type='Unknown', value=value, code=code)\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#def-_handle_annassign","title":"<code>def _handle_annassign</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>stmt: StandardReturn</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>str</code></p> Docstring <p>Generates a Markdown representation for an <code>annotated assign</code> statement.</p> <p>This function processes a <code>token: type = value</code> statement from a parsed Python file, formatting into a structured Markdown block. The output includes the assign name, annotation, value and the indented code snippet.</p> <p>Key concepts: - Annotated Assign Handling: Extracts the assign statement's details (name, annot,     value, code) and formats them for documentation. - Indentation: The <code>indent_code</code> function is used to apply consistent indentation     to the statement code before including it in the Markdown output. - MD Struct: The output Markdown uses a predefined template - <code>ASSIGN_MD_STRUCT</code>.</p> <p>Example:</p> Python<pre><code>stmt: StandardReturn = {\n    'statement': Statement.AnnAssign,\n    'name': 'var',\n    'annot': 'str',\n    'value': '\"example\"',\n    'code': 'var: str = \"example\"',\n}\nhandle_annassign(stmt)\n# Outputs a formatted Markdown string representing the annotated assign\n</code></pre> <p>:param stmt: A dict containing the details of the annassign statement.</p> <p>:type stmt: StandardReturn</p> <p>:return: A formatted Markdown string documenting the annassign statement.</p> <p>:rtype: str</p> Snippet Python<pre><code>def _handle_annassign(stmt: StandardReturn) -&gt; str:\n    \"\"\"\n    Generates a Markdown representation for an `annotated assign` statement.\n\n    This function processes a `token: type = value` statement from a parsed Python file,\n    formatting into a structured Markdown block. The output includes the assign name,\n    annotation, value and the indented code snippet.\n\n    Key concepts:\n    - Annotated Assign Handling: Extracts the assign statement's details (name, annot,\n        value, code) and formats them for documentation.\n    - Indentation: The `indent_code` function is used to apply consistent indentation\n        to the statement code before including it in the Markdown output.\n    - MD Struct: The output Markdown uses a predefined template - `ASSIGN_MD_STRUCT`.\n\n    Example:\n\n    ```python\n    stmt: StandardReturn = {\n        'statement': Statement.AnnAssign,\n        'name': 'var',\n        'annot': 'str',\n        'value': '\"example\"',\n        'code': 'var: str = \"example\"',\n    }\n    handle_annassign(stmt)\n    # Outputs a formatted Markdown string representing the annotated assign\n    ```\n\n    :param stmt: A dict containing the details of the annassign statement.\n    :type stmt: StandardReturn\n    :return: A formatted Markdown string documenting the annassign statement.\n    :rtype: str\n    \"\"\"\n    name: Token = cast(Token, stmt['name'])\n    annot: Annotation = cast(Annotation, stmt['annot'])\n    value: Value = cast(Value, stmt['value'])\n    code: CodeSnippet = indent_code(cast(str, stmt['code']))\n    return ASSIGN_MD_STRUCT.format(token=name, _type=annot, value=value, code=code)\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#def-_handle_class_def","title":"<code>def _handle_class_def</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>stmt: StandardReturn</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>str</code></p> Docstring <p>Generates a Markdown representation for a <code>class</code> definition statement.</p> <p>This function processes a class definition from a parsed Python codebase, extracting key details such as the class name, inheritance, decorators, keyword arguments and the code itself. It formats this information into a structured Markdown block for documentation purposes.</p> <p>Key concepts: - Class Handling: Extracts information about the class, including its name,     inheritance hierarchy and decorators. - Indentation: Applies consistent indentation to the class code using the     <code>indent_code</code> function. - Markdown Structure: Utilizes a predefined template (<code>CLASS_DEF_MD_STRUCT</code>)     to format the class details in Markdown.</p> <p>Example:</p> Python<pre><code>stmt: StandardReturn = {\n    'statement': Statement.ClassDef,\n    'name': 'MyClass',\n    'inheritance': ['BaseClass'],\n    'decorators': ['@dataclass'],\n    'kwargs': '',\n    'code': '@dataclass\\nclass MyClass(BaseClass): ...',\n}\nhandle_class_def(stmt)\n# Outputs a formatted Markdown string representing the class definition\n</code></pre> <p>:param stmt: A dict containing the details of the class definition statement.</p> <p>:type stmt: StandardReturn</p> <p>:return: A formatted Markdown string documenting the class definition.</p> <p>:rtype: str</p> Snippet Python<pre><code>def _handle_class_def(stmt: StandardReturn) -&gt; str:\n    \"\"\"\n    Generates a Markdown representation for a `class` definition statement.\n\n    This function processes a class definition from a parsed Python codebase,\n    extracting key details such as the class name, inheritance, decorators,\n    keyword arguments and the code itself. It formats this information into\n    a structured Markdown block for documentation purposes.\n\n    Key concepts:\n    - Class Handling: Extracts information about the class, including its name,\n        inheritance hierarchy and decorators.\n    - Indentation: Applies consistent indentation to the class code using the\n        `indent_code` function.\n    - Markdown Structure: Utilizes a predefined template (`CLASS_DEF_MD_STRUCT`)\n        to format the class details in Markdown.\n\n    Example:\n\n    ```python\n    stmt: StandardReturn = {\n        'statement': Statement.ClassDef,\n        'name': 'MyClass',\n        'inheritance': ['BaseClass'],\n        'decorators': ['@dataclass'],\n        'kwargs': '',\n        'code': '@dataclass\\\\nclass MyClass(BaseClass): ...',\n    }\n    handle_class_def(stmt)\n    # Outputs a formatted Markdown string representing the class definition\n    ```\n\n    :param stmt: A dict containing the details of the class definition statement.\n    :type stmt: StandardReturn\n    :return: A formatted Markdown string documenting the class definition.\n    :rtype: str\n    \"\"\"\n    name: Token = cast(Token, stmt['name'])\n    inheritance: Inheritance = ', '.join(cast(list[Inheritance], stmt['inheritance']))\n    decorators: Decorator = ', '.join(cast(list[Decorator], stmt['decorators'])) or 'None'\n    kwargs: Kwargs = cast(Kwargs, stmt['kwargs'])\n    code: CodeSnippet = indent_code(cast(str, stmt['code']))\n    if (docstring := cast(Docstring | None, stmt['docstring'])):\n        docstring = indent_code(docstring)\n    else:\n        docstring = indent_code('No docstring provided.')\n    if not inheritance:\n        inheritance = 'None'\n    if not kwargs:\n        kwargs = 'None'\n    return CLASS_DEF_MD_STRUCT.format(name=name, docstring=docstring, inheritance=inheritance, decorators=decorators, kwargs=kwargs, code=code)\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#def-_handle_function_def","title":"<code>def _handle_function_def</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>stmt: StandardReturn</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>str</code></p> Docstring <p>Generates a Markdown representation for a function definition statement.</p> <p>This function processes a function or method definition from a parsed Python codebase, extracting details such as the function name, decorators, arguments, keyword arguments, return type and the code itself. It formats this information into a structured Markdown block for documentation purposes.</p> <p>Key concepts: - Function Handling: Extracts the function's metadata, including decorators,     arguments, and return type. - Indentation: Applies consistent indentation to the function code using the     <code>indent_code</code> function. - Markdown Structure: Utilizes a predefined template (<code>FUNCTION_DEF_MD_STRUCT</code>)     to format the function details in Markdown.</p> <p>Example:</p> Python<pre><code>stmt: StandardReturn = {\n    'statement': Statement.FunctionDef,\n    'name': 'sum_thing',\n    'decorators': [''],\n    'args': 'x: int, y: int',\n    'kwargs': '',\n    'rtype': 'int',\n    'code': 'def sum_thing(x: int, y: int) -&gt; int: return x + y',\n}\nhandle_function_def(stmt)\n# Outputs a formatted Markdown string representing the function definition\n</code></pre> <p>:param stmt: A dict containing the details of the function definition statement.</p> <p>:type stmt: StandardReturn</p> <p>:return: A formatted Markdown string documenting the function definition.</p> <p>:rtype: str</p> Snippet Python<pre><code>def _handle_function_def(stmt: StandardReturn) -&gt; str:\n    \"\"\"\n    Generates a Markdown representation for a function definition statement.\n\n    This function processes a function or method definition from a parsed Python\n    codebase, extracting details such as the function name, decorators, arguments,\n    keyword arguments, return type and the code itself. It formats this information\n    into a structured Markdown block for documentation purposes.\n\n    Key concepts:\n    - Function Handling: Extracts the function's metadata, including decorators,\n        arguments, and return type.\n    - Indentation: Applies consistent indentation to the function code using the\n        `indent_code` function.\n    - Markdown Structure: Utilizes a predefined template (`FUNCTION_DEF_MD_STRUCT`)\n        to format the function details in Markdown.\n\n    Example:\n\n    ```python\n    stmt: StandardReturn = {\n        'statement': Statement.FunctionDef,\n        'name': 'sum_thing',\n        'decorators': [''],\n        'args': 'x: int, y: int',\n        'kwargs': '',\n        'rtype': 'int',\n        'code': 'def sum_thing(x: int, y: int) -&gt; int: return x + y',\n    }\n    handle_function_def(stmt)\n    # Outputs a formatted Markdown string representing the function definition\n    ```\n\n    :param stmt: A dict containing the details of the function definition statement.\n    :type stmt: StandardReturn\n    :return: A formatted Markdown string documenting the function definition.\n    :rtype: str\n    \"\"\"\n    name: Token = cast(Token, stmt['name'])\n    decorators: Decorator = ', '.join(cast(list[Decorator], stmt['decorators'])) or 'None'\n    category: FunctionType = cast(FunctionType, stmt['category'])\n    rtype: Annotation = cast(Annotation, stmt['rtype']) or 'Unknown'\n    code: CodeSnippet = indent_code(cast(str, stmt['code']))\n    if (docstring := cast(Docstring | None, stmt['docstring'])):\n        docstring = indent_code(docstring.replace(':param', '\\n:param').replace(':type', '\\n:type').replace(':return', '\\n:return').replace(':rtype', '\\n:rtype'))\n    else:\n        docstring = indent_code('No docstring provided.')\n    if not (args := cast(Args, stmt['args'])):\n        args = 'None'\n    if not (kwargs := cast(Kwargs, stmt['kwargs'])):\n        kwargs = 'None'\n    return FUNCTION_DEF_MD_STRUCT.format(name=name, docstring=docstring, decorators=decorators, category=category.value, args=args, kwargs=kwargs, rtype=rtype, code=code)\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#def-_handle_assert","title":"<code>def _handle_assert</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>stmt: StandardReturn</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>str</code></p> Docstring <p>Generates a Markdown representation for an <code>assert</code> statement.</p> <p>This function processes a <code>assert x</code> statement from a parsed Python codebase, extracting the test condition, optional message and the code itself. It formats this information into a structured Markdown block for documentation purposes.</p> <p>Key concepts: - Assertion Handling: Extracts the test condition and message from the assert     statement. - Indentation: Applies consistent indentation to the assert code using the     <code>indent_code</code> function. - Markdown Structure: Utilizes a predefined template (<code>ASSERT_MD_STRUCT</code>)     to format the assertion details in Markdown.</p> <p>Example:</p> Python<pre><code>stmt: StandardReturn = {\n    'statement': Statement.Assert,\n    'test': 'x &gt; 0',\n    'msg': '\"x must be positive\"',\n    'code': 'assert x &gt; 0, \"x must be positive\"',\n}\nhandle_assert(stmt)\n# Outputs a formatted Markdown string representing the assert statement\n</code></pre> <p>:param stmt: A dictionary containing the details of the assert statement.</p> <p>:type stmt: StandardReturn</p> <p>:return: A formatted Markdown string documenting the assert statement.</p> <p>:rtype: str</p> Snippet Python<pre><code>def _handle_assert(stmt: StandardReturn) -&gt; str:\n    \"\"\"\n    Generates a Markdown representation for an `assert` statement.\n\n    This function processes a `assert x` statement from a parsed Python codebase,\n    extracting the test condition, optional message and the code itself. It formats\n    this information into a structured Markdown block for documentation purposes.\n\n    Key concepts:\n    - Assertion Handling: Extracts the test condition and message from the assert\n        statement.\n    - Indentation: Applies consistent indentation to the assert code using the\n        `indent_code` function.\n    - Markdown Structure: Utilizes a predefined template (`ASSERT_MD_STRUCT`)\n        to format the assertion details in Markdown.\n\n    Example:\n\n    ```python\n    stmt: StandardReturn = {\n        'statement': Statement.Assert,\n        'test': 'x &gt; 0',\n        'msg': '\"x must be positive\"',\n        'code': 'assert x &gt; 0, \"x must be positive\"',\n    }\n    handle_assert(stmt)\n    # Outputs a formatted Markdown string representing the assert statement\n    ```\n\n    :param stmt: A dictionary containing the details of the assert statement.\n    :type stmt: StandardReturn\n    :return: A formatted Markdown string documenting the assert statement.\n    :rtype: str\n    \"\"\"\n    test: AssertionTest = cast(AssertionTest, stmt['test'])\n    msg: AssertionMessage = cast(AssertionMessage, stmt['msg'])\n    code: CodeSnippet = indent_code(cast(str, stmt['code']))\n    return ASSERT_MD_STRUCT.format(test=test, msg=msg, code=code)\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#def-get_update_set_nav","title":"<code>def get_update_set_nav</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>mkdocs_yml: FilePath, cleaned_codebase: CodebaseDict, codebase_nav_path: str</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>None</code></p> Docstring <p>Sets the <code>mkdocs.yml</code> Nav \"Codebase\" section to the current state, updating it.</p> <p>Reading the current <code>mkdocs.yml</code> file, loads and parses it's data, extracts the \"Nav\" section and search for the Expected Codebase Nav path, defaulting to <code>'Codebase'</code>; after this, if success, updates the nav list with the new codebase data and, finally, saves this changes dumping the file updating just the codebase section.</p> <p>:param mkdocs_yml: Ready-to-use \"mkdocs.yml\" path.</p> <p>:type mkdocs_yml: FilePath</p> <p>:param codebase: Dict containing nodes representing <code>.py</code> files and their stmts.</p> <p>:type codebase: CodebaseDict</p> <p>:param codebase_nav_path: Expected codebase nav name to be used/found.</p> <p>:type codebase_nav_path: str = 'Codebase'</p> <p>:return: None</p> <p>:rtype: None</p> Snippet Python<pre><code>def get_update_set_nav(mkdocs_yml: FilePath, cleaned_codebase: CodebaseDict, codebase_nav_path: str='Codebase') -&gt; None:\n    \"\"\"\n    Sets the `mkdocs.yml` Nav \"Codebase\" section to the current state, updating it.\n\n    Reading the current `mkdocs.yml` file, loads and parses it's data, extracts the\n    \"Nav\" section and search for the Expected Codebase Nav path, defaulting to\n    `'Codebase'`; after this, if success, updates the nav list with the new codebase\n    data and, finally, saves this changes dumping the file updating just the codebase\n    section.\n\n    :param mkdocs_yml: Ready-to-use \"mkdocs.yml\" path.\n    :type mkdocs_yml: FilePath\n    :param codebase: Dict containing nodes representing `.py` files and their stmts.\n    :type codebase: CodebaseDict\n    :param codebase_nav_path: Expected codebase nav name to be used/found.\n    :type codebase_nav_path: str = 'Codebase'\n    :return: None\n    :rtype: None\n    \"\"\"\n    with open(mkdocs_yml, encoding='utf-8') as f:\n        yml: dict[str, list[Any]] = load(f.read(), Loader=CLoader)\n        try:\n            nav_section_index: int = list((list(i.keys())[0] for i in yml['nav'])).index(codebase_nav_path)\n        except ValueError:\n            logger.error(f'Nav section \"{codebase_nav_path}\" not found')\n            exit()\n    yml['nav'][nav_section_index] = {codebase_nav_path: build_nav_struct(cleaned_codebase, codebase_nav_path)}\n    with open(mkdocs_yml, 'w', encoding='utf-8') as f:\n        f.write(dump(yml, Dumper=CDumper, sort_keys=False, indent=2))\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#def-write_homepage","title":"<code>def write_homepage</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>output_path: FilePath, readme_path: FilePath</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>None</code></p> Docstring <p>Reads the content of a given README file path and writes to the doc homepage.</p> <p>As simple as can be, just add some MkDocs lines to remove (hide) both ToC and navigation, so the page has nothing on the sides, giving more space for the main content.</p> <p>:param output_path: String for the documentation output.</p> <p>:type output_path: FilePath</p> <p>:param readme_path: String for the README file.</p> <p>:type readme_path: FilePath</p> <p>:return: None</p> <p>:rtype: None</p> Snippet Python<pre><code>def write_homepage(output_path: FilePath, readme_path: FilePath) -&gt; None:\n    \"\"\"\n    Reads the content of a given README file path and writes to the doc homepage.\n\n    As simple as can be, just add some MkDocs lines to remove (hide) both ToC and\n    navigation, so the page has nothing on the sides, giving more space for the\n    main content.\n\n    :param output_path: String for the documentation output.\n    :type output_path: FilePath\n    :param readme_path: String for the README file.\n    :type readme_path: FilePath\n    :return: None\n    :rtype: None\n    \"\"\"\n    homepage: str = path.join(output_path, 'docs', 'index.md')\n    with open(readme_path, encoding='utf-8') as f:\n        content: list[str] = f.readlines()\n    with open(homepage, 'w', encoding='utf-8') as f:\n        readme_to_write: list[str] = ['---\\n', 'hide:\\n', '  - navigation\\n', '  - toc\\n', '---\\n', '\\n', '&lt;br&gt;\\n', '\\n'] + content\n        f.writelines(readme_to_write)\n    logger.info('\"README.md\" copied to documentation')\n</code></pre>"},{"location":"Codebase/mosheh/doc/shared.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"Codebase/mosheh/doc/update.py/","title":"File: <code>update.py</code>","text":"<p>Role:  Python Source Code</p> <p>Path: <code>mosheh.doc</code></p> <p>Used to update the Nav and optionally the homepage of a documentation site, this file handles the <code>types.basic.CodebaseDict</code> and rewrites the <code>mkdocs.yml</code> Nav structure based on its contents.</p> <p>The only existing function here is <code>update_doc</code>, which encapsulates all underlying logic and utility calls.</p> <p>There\u2019s logic for safely cleaning the codebase, rebuilding the navigation tree, modifying the YAML structure, and copying over the README to serve as homepage, all using internal calls for functions such as <code>process_codebase</code> and <code>get_update_set_nav</code>.</p>"},{"location":"Codebase/mosheh/doc/update.py/#imports","title":"Imports","text":""},{"location":"Codebase/mosheh/doc/update.py/#import-logger","title":"<code>import Logger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import Logger\n</code></pre>"},{"location":"Codebase/mosheh/doc/update.py/#import-getlogger","title":"<code>import getLogger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import getLogger\n</code></pre>"},{"location":"Codebase/mosheh/doc/update.py/#import-path","title":"<code>import path</code>","text":"<p>Path: <code>os</code></p> <p>Category: native</p> Snippet Python<pre><code>from os import path\n</code></pre>"},{"location":"Codebase/mosheh/doc/update.py/#import-get_update_set_nav","title":"<code>import get_update_set_nav</code>","text":"<p>Path: <code>mosheh.doc.shared</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.doc.shared import get_update_set_nav\n</code></pre>"},{"location":"Codebase/mosheh/doc/update.py/#import-process_codebase","title":"<code>import process_codebase</code>","text":"<p>Path: <code>mosheh.doc.shared</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.doc.shared import process_codebase\n</code></pre>"},{"location":"Codebase/mosheh/doc/update.py/#import-write_homepage","title":"<code>import write_homepage</code>","text":"<p>Path: <code>mosheh.doc.shared</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.doc.shared import write_homepage\n</code></pre>"},{"location":"Codebase/mosheh/doc/update.py/#import-codebasedict","title":"<code>import CodebaseDict</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import CodebaseDict\n</code></pre>"},{"location":"Codebase/mosheh/doc/update.py/#import-filepath","title":"<code>import FilePath</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import FilePath\n</code></pre>"},{"location":"Codebase/mosheh/doc/update.py/#import-remove_abspath_from_codebase","title":"<code>import remove_abspath_from_codebase</code>","text":"<p>Path: <code>mosheh.utils</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.utils import remove_abspath_from_codebase\n</code></pre>"},{"location":"Codebase/mosheh/doc/update.py/#consts","title":"Consts","text":"<p>NO CONSTANT DEFINED HERE</p>"},{"location":"Codebase/mosheh/doc/update.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"Codebase/mosheh/doc/update.py/#functions","title":"Functions","text":""},{"location":"Codebase/mosheh/doc/update.py/#def-update_doc","title":"<code>def update_doc</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>None</code></p> <p>Kwargs: <code>codebase: CodebaseDict, root: str, output: str, readme_path: str | None, codebase_nav_path: str = 'Codebase'</code></p> <p>Return Type: <code>None</code></p> Docstring <p>Updates an existing documentation for a Python codebase using MkDocs.</p> <p>This function updates a MkDocs project at the specified output path, rewrites a configuration file and processes the provided codebase to generate documentation.</p> <p>Key concepts:     - Kwargs: By starting args with \"*\", this function only accepts key-word     arguments.     - MkDocs: A static site generator that's geared towards project documentation.     - Codebase Processing: The function relies on <code>process_codebase</code> to handle the     codebase structure and populate the documentation content based on Python files     and their stmts.     - Configuration: Rebuilds a <code>mkdocs.yml</code> Nav config file with new project     details.     - Homepage: If <code>readme_path</code> is provided, so the <code>index.md</code> file provided by     MkDocs is overwriten by the <code>README.md</code> found at provided <code>readme_path</code> file.</p> <p>:param codebase: Dict containing nodes representing <code>.py</code> files and their stmts.</p> <p>:type codebase: CodebaseDict</p> <p>:param root: Root dir, where the analysis starts.</p> <p>:type root: str</p> <p>:param output: Path for documentation output, where to be created.</p> <p>:type output: str</p> <p>:param readme_path: The path of the <code>README.md</code> file, to be used as homepage.</p> <p>:type readme_path: str | None</p> <p>:param codebase_nav_path: Expected codebase nav name to be used/found.</p> <p>:type codebase_nav_path: str = 'Codebase'</p> <p>:return: None</p> <p>:rtype: None</p> Snippet Python<pre><code>def update_doc(*, codebase: CodebaseDict, root: str, output: str, readme_path: str | None, codebase_nav_path: str='Codebase') -&gt; None:\n    \"\"\"\n    Updates an existing documentation for a Python codebase using MkDocs.\n\n    This function updates a MkDocs project at the specified output path, rewrites a\n    configuration file and processes the provided codebase to generate documentation.\n\n    Key concepts:\n        - Kwargs: By starting args with \"*\", this function only accepts key-word\n        arguments.\n        - MkDocs: A static site generator that's geared towards project documentation.\n        - Codebase Processing: The function relies on `process_codebase` to handle the\n        codebase structure and populate the documentation content based on Python files\n        and their stmts.\n        - Configuration: Rebuilds a `mkdocs.yml` Nav config file with new project\n        details.\n        - Homepage: If `readme_path` is provided, so the `index.md` file provided by\n        MkDocs is overwriten by the `README.md` found at provided `readme_path` file.\n\n    :param codebase: Dict containing nodes representing `.py` files and their stmts.\n    :type codebase: CodebaseDict\n    :param root: Root dir, where the analysis starts.\n    :type root: str\n    :param output: Path for documentation output, where to be created.\n    :type output: str\n    :param readme_path: The path of the `README.md` file, to be used as homepage.\n    :type readme_path: str | None\n    :param codebase_nav_path: Expected codebase nav name to be used/found.\n    :type codebase_nav_path: str = 'Codebase'\n    :return: None\n    :rtype: None\n    \"\"\"\n    clean_codebase: CodebaseDict = remove_abspath_from_codebase(codebase)\n    output_path: str = path.abspath(output)\n    mkdocs_yml: FilePath = path.join(output_path, 'mkdocs.yml')\n    logger.info('Processing codebase')\n    process_codebase(clean_codebase, root, output, codebase_nav_path=codebase_nav_path)\n    logger.info('Codebase processed successfully')\n    logger.info('Getting and updating Nav')\n    get_update_set_nav(mkdocs_yml, clean_codebase, codebase_nav_path)\n    logger.debug('\\tNav addeded to mkdocs.yml')\n    if readme_path:\n        write_homepage(output_path, readme_path)\n</code></pre>"},{"location":"Codebase/mosheh/doc/update.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"Codebase/mosheh/handlers/__init__.py/","title":"File: <code>__init__.py</code>","text":"<p>Role:  Python Source Code</p> <p>Path: <code>mosheh.handlers</code></p> <p>No file docstring provided.</p>"},{"location":"Codebase/mosheh/handlers/__init__.py/#imports","title":"Imports","text":""},{"location":"Codebase/mosheh/handlers/__init__.py/#import-handle_python_file","title":"<code>import handle_python_file</code>","text":"<p>Path: <code>mosheh.handlers.python</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.handlers.python import handle_python_file\n</code></pre>"},{"location":"Codebase/mosheh/handlers/__init__.py/#consts","title":"Consts","text":"<p>NO CONSTANT DEFINED HERE</p>"},{"location":"Codebase/mosheh/handlers/__init__.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"Codebase/mosheh/handlers/__init__.py/#functions","title":"Functions","text":"<p>NO FUNCTION DEFINED HERE</p>"},{"location":"Codebase/mosheh/handlers/__init__.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"Codebase/mosheh/handlers/python.py/","title":"File: <code>python.py</code>","text":"<p>Role:  Python Source Code</p> <p>Path: <code>mosheh.handlers</code></p> <p>This file's role is process the source python codebase.</p> <p>By calling <code>handle_std_nodes</code> with an <code>ast.AST</code> node, it's going to parse the node type and call the right handle func. The defined nodes are <code>ast.Import</code>, <code>ast.ImportFrom</code>, <code>ast.Assign</code>, <code>ast.AnnAssign</code>, <code>ast.FunctionDef</code>, <code>ast.AsyncFunctionDef</code>, <code>ast.ClassDef</code> and <code>ast.Assert</code>; if more nodes inside them, <code>_handle_node</code> is called to process the new one.</p>"},{"location":"Codebase/mosheh/handlers/python.py/#imports","title":"Imports","text":""},{"location":"Codebase/mosheh/handlers/python.py/#import-ast","title":"<code>import ast</code>","text":"<p>Path: <code>None</code></p> <p>Category: native</p> Snippet Python<pre><code>import ast\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-defaultdict","title":"<code>import defaultdict</code>","text":"<p>Path: <code>collections</code></p> <p>Category: native</p> Snippet Python<pre><code>from collections import defaultdict\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-logger","title":"<code>import Logger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import Logger\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-getlogger","title":"<code>import getLogger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: native</p> Snippet Python<pre><code>from logging import getLogger\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-sep","title":"<code>import sep</code>","text":"<p>Path: <code>os</code></p> <p>Category: native</p> Snippet Python<pre><code>from os import sep\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-any","title":"<code>import Any</code>","text":"<p>Path: <code>typing</code></p> <p>Category: native</p> Snippet Python<pre><code>from typing import Any\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-final","title":"<code>import Final</code>","text":"<p>Path: <code>typing</code></p> <p>Category: native</p> Snippet Python<pre><code>from typing import Final\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-acceptable_lower_constants","title":"<code>import ACCEPTABLE_LOWER_CONSTANTS</code>","text":"<p>Path: <code>mosheh.constants</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.constants import ACCEPTABLE_LOWER_CONSTANTS\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-builtin_dunder_methods","title":"<code>import BUILTIN_DUNDER_METHODS</code>","text":"<p>Path: <code>mosheh.constants</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.constants import BUILTIN_DUNDER_METHODS\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-builtin_modules","title":"<code>import BUILTIN_MODULES</code>","text":"<p>Path: <code>mosheh.constants</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.constants import BUILTIN_MODULES\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-annotation","title":"<code>import Annotation</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Annotation\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-args","title":"<code>import Args</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Args\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-assertionmessage","title":"<code>import AssertionMessage</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import AssertionMessage\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-assertiontest","title":"<code>import AssertionTest</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import AssertionTest\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-codesnippet","title":"<code>import CodeSnippet</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import CodeSnippet\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-decorator","title":"<code>import Decorator</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Decorator\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-defaultvalue","title":"<code>import DefaultValue</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import DefaultValue\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-docstring","title":"<code>import Docstring</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Docstring\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-filepath","title":"<code>import FilePath</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import FilePath\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-importedidentifier","title":"<code>import ImportedIdentifier</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import ImportedIdentifier\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-inheritance","title":"<code>import Inheritance</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Inheritance\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-kwargs","title":"<code>import Kwargs</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Kwargs\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-modulepath","title":"<code>import ModulePath</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import ModulePath\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-standardreturn","title":"<code>import StandardReturn</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import StandardReturn\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-token","title":"<code>import Token</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Token\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-value","title":"<code>import Value</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Value\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-annassigncontract","title":"<code>import AnnAssignContract</code>","text":"<p>Path: <code>mosheh.types.contracts</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.contracts import AnnAssignContract\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-assertcontract","title":"<code>import AssertContract</code>","text":"<p>Path: <code>mosheh.types.contracts</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.contracts import AssertContract\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-assigncontract","title":"<code>import AssignContract</code>","text":"<p>Path: <code>mosheh.types.contracts</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.contracts import AssignContract\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-asyncfunctiondefcontract","title":"<code>import AsyncFunctionDefContract</code>","text":"<p>Path: <code>mosheh.types.contracts</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.contracts import AsyncFunctionDefContract\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-classdefcontract","title":"<code>import ClassDefContract</code>","text":"<p>Path: <code>mosheh.types.contracts</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.contracts import ClassDefContract\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-functiondefcontract","title":"<code>import FunctionDefContract</code>","text":"<p>Path: <code>mosheh.types.contracts</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.contracts import FunctionDefContract\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-importcontract","title":"<code>import ImportContract</code>","text":"<p>Path: <code>mosheh.types.contracts</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.contracts import ImportContract\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-importfromcontract","title":"<code>import ImportFromContract</code>","text":"<p>Path: <code>mosheh.types.contracts</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.contracts import ImportFromContract\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-filerole","title":"<code>import FileRole</code>","text":"<p>Path: <code>mosheh.types.enums</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.enums import FileRole\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-functiontype","title":"<code>import FunctionType</code>","text":"<p>Path: <code>mosheh.types.enums</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.enums import FunctionType\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-importtype","title":"<code>import ImportType</code>","text":"<p>Path: <code>mosheh.types.enums</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.enums import ImportType\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-statement","title":"<code>import Statement</code>","text":"<p>Path: <code>mosheh.types.enums</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.enums import Statement\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-add_to_nested_defaultdict","title":"<code>import add_to_nested_defaultdict</code>","text":"<p>Path: <code>mosheh.utils</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.utils import add_to_nested_defaultdict\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-bin","title":"<code>import bin</code>","text":"<p>Path: <code>mosheh.utils</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.utils import bin\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-get_import_type","title":"<code>import get_import_type</code>","text":"<p>Path: <code>mosheh.utils</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.utils import get_import_type\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#import-standard_struct","title":"<code>import standard_struct</code>","text":"<p>Path: <code>mosheh.utils</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.utils import standard_struct\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#consts","title":"Consts","text":"<p>NO CONSTANT DEFINED HERE</p>"},{"location":"Codebase/mosheh/handlers/python.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"Codebase/mosheh/handlers/python.py/#functions","title":"Functions","text":""},{"location":"Codebase/mosheh/handlers/python.py/#def-handle_python_file","title":"<code>def handle_python_file</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>codebase: defaultdict[Any, Any], file: FilePath</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>defaultdict[Any, Any]</code></p> Docstring <p>Processes the .py file and returns it's data.</p> <p>By receiving the codebase datastructure, empty or not, and a file_path, first parses the code, then defines the file metadata, such as role (from <code>types.enums.FileRole</code>), navigates into it's AST nodes (statements) and calls the <code>handle_std_nodes</code> function for dealing with the default observed statements.</p> <p>:param codebase: Nested defaultdict with the codebase data, empty or not.</p> <p>:type codebase: defaultdict[Any, Any]</p> <p>:param file: Path for the Python file to be documented.</p> <p>:type file: FilePath</p> <p>:return: The same codebase data struct, with the parsed file.</p> <p>:rtype: defaultdict[Any, Any]</p> Snippet Python<pre><code>def handle_python_file(codebase: defaultdict[Any, Any], file: FilePath) -&gt; defaultdict[Any, Any]:\n    \"\"\"\n    Processes the .py file and returns it's data.\n\n    By receiving the codebase datastructure, empty or not, and a file_path, first\n    parses the code, then defines the file metadata, such as role (from\n    `types.enums.FileRole`), navigates into it's AST nodes (statements) and calls the\n    `handle_std_nodes` function for dealing with the default observed statements.\n\n    :param codebase: Nested defaultdict with the codebase data, empty or not.\n    :type codebase: defaultdict[Any, Any]\n    :param file: Path for the Python file to be documented.\n    :type file: FilePath\n    :return: The same codebase data struct, with the parsed file.\n    :rtype: defaultdict[Any, Any]\n    \"\"\"\n    with open(file, encoding='utf-8') as f:\n        code: str = f.read()\n    tree: ast.AST = ast.parse(code, filename=file)\n    logger.debug('\\tCode tree parsed')\n    statements: list[StandardReturn] = []\n    __meta__: StandardReturn = {'__role__': FileRole.PythonSourceCode if file.endswith('.py') else FileRole.PythonStubFile, '__docstring__': 'No file docstring provided.'}\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Module) and (__docstring__ := ast.get_docstring(node)):\n            __meta__['__docstring__'] = __docstring__\n        elif isinstance(node, ast.ClassDef):\n            _mark_methods(node)\n        elif isinstance(node, ast.FunctionDef) and getattr(node, 'parent', None):\n            continue\n        data: list[StandardReturn] = _handle_std_nodes(node)\n        if data:\n            statements.extend(data)\n            logger.debug(\"\\tNode inserted into file's structure\")\n    statements.insert(0, __meta__)\n    add_to_nested_defaultdict(codebase, file.split(sep), statements)\n    logger.debug(f'\\t{file} parsing successfully done')\n    return codebase\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#def-_handle_std_nodes","title":"<code>def _handle_std_nodes</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>node: ast.AST</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>list[StandardReturn]</code></p> Docstring <p>Processes an abstract syntax tree (AST) node and returns a handler for the node.</p> <p>This function analyzes a given <code>ast.AST</code> node, determines its type, and processes it using the appropriate handler function. It supports a variety of node types such as imports, constants, functions, classes, and assertions, delegating the handling to specialized functions for each case.</p> <p>The function categorizes and handles nodes as follows: - Imports: <code>ast.Import | ast.ImportFrom</code> - Constants: <code>ast.Assign | ast.AnnAssign</code> - Functions: <code>ast.FunctionDef | ast.AsyncFunctionDef</code> - Classes: <code>ast.ClassDef</code> - Assertions: <code>ast.Assert</code></p> <p>:param node: The AST node to process.</p> <p>:type node: ast.AST</p> <p>:return: An object containing information associated with the node.</p> <p>:rtype: list[StandardReturn]</p> Snippet Python<pre><code>def _handle_std_nodes(node: ast.AST) -&gt; list[StandardReturn]:\n    \"\"\"\n    Processes an abstract syntax tree (AST) node and returns a handler for the node.\n\n    This function analyzes a given `ast.AST` node, determines its type, and processes\n    it using the appropriate handler function. It supports a variety of node types such\n    as imports, constants, functions, classes, and assertions, delegating the handling\n    to specialized functions for each case.\n\n    The function categorizes and handles nodes as follows:\n    - Imports: `ast.Import | ast.ImportFrom`\n    - Constants: `ast.Assign | ast.AnnAssign`\n    - Functions: `ast.FunctionDef | ast.AsyncFunctionDef`\n    - Classes: `ast.ClassDef`\n    - Assertions: `ast.Assert`\n\n    :param node: The AST node to process.\n    :type node: ast.AST\n    :return: An object containing information associated with the node.\n    :rtype: list[StandardReturn]\n    \"\"\"\n    data: list[StandardReturn] = []\n    if not isinstance(node, ast.Import | ast.ImportFrom | ast.Assign | ast.AnnAssign | ast.FunctionDef | ast.AsyncFunctionDef | ast.ClassDef | ast.Assert):\n        return data\n    logger.debug(f'\\tStd node found: {type(node)}')\n    if isinstance(node, ast.Import):\n        data = _handle_import(data, node)\n    elif isinstance(node, ast.ImportFrom):\n        data = _handle_import_from(data, node)\n    elif isinstance(node, ast.Assign):\n        lst: list[str] = []\n        for i in node.targets:\n            lst.extend(_handle_node(i))\n        if any(map(str.isupper, lst)) or any(map(lambda x: bin(x, ACCEPTABLE_LOWER_CONSTANTS), lst)):\n            data = _handle_assign(data, node)\n    elif isinstance(node, ast.AnnAssign):\n        if isinstance(node.target, ast.Name) and node.target.id.isupper():\n            data = _handle_annassign(data, node)\n    elif isinstance(node, ast.FunctionDef):\n        data = _handle_function_def(data, node)\n    elif isinstance(node, ast.AsyncFunctionDef):\n        data = _handle_async_function_def(data, node)\n    elif isinstance(node, ast.ClassDef):\n        data = _handle_class_def(data, node)\n    else:\n        data = _handle_assert(data, node)\n    return data\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#def-_handle_node","title":"<code>def _handle_node</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>node: ast.AST</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>list[str]</code></p> Docstring <p>Converts an AST node back into its string representation.</p> <p>This function takes an AST node and uses <code>ast.unparse</code> to convert it into the equivalent source code. It returns the string inside a list to maintain a consistent return type with other handlers.</p> <p>Key concepts: - AST Parsing: The core concept is converting an AST object back to source code. - Null-Safe Handling: If the node is <code>None</code>, it returns <code>None</code> to avoid errors.</p> <p>:param node: The AST node to be processed.</p> <p>:type node: ast.AST</p> <p>:return: A list containing the unparsed source code, or 'None' if the node is None.</p> <p>:rtype: list[str]</p> Snippet Python<pre><code>def _handle_node(node: ast.AST) -&gt; list[str]:\n    \"\"\"\n    Converts an AST node back into its string representation.\n\n    This function takes an AST node and uses `ast.unparse` to convert it\n    into the equivalent source code. It returns the string inside a list\n    to maintain a consistent return type with other handlers.\n\n    Key concepts:\n    - AST Parsing: The core concept is converting an AST object back to source code.\n    - Null-Safe Handling: If the node is `None`, it returns `None` to avoid errors.\n\n    :param node: The AST node to be processed.\n    :type node: ast.AST\n    :return: A list containing the unparsed source code, or 'None' if the node is None.\n    :rtype: list[str]\n    \"\"\"\n    return [ast.unparse(node)]\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#def-__handle_import","title":"<code>def __handle_import</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>imported_identifier: ImportedIdentifier</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>StandardReturn</code></p> Docstring <p>Constructs a standardized dictionary representation for an import statement.</p> <p>This function processes the given library name, determines its import category (local, native, or third-party), and builds a standardized dictionary structure representing the import statement. The resulting data includes information about the statement type, library name, import category, and the generated import code.</p> <p>Key concepts: - Import Categorization: Determines whether the library is native (built-in),   third-party, or local. - Standardized Structure: Returns a dictionary conforming to the <code>StandardReturn</code>   format, ensuring consistency across codebase documentation. - Dynamic Code Generation: Constructs the import statement dynamically based on   the library name.</p> <p>Example:</p> Python<pre><code>data: StandardReturn = __handle_import('os')\ndata\n# {\n#     'statement': Statement.Import,\n#     'name': 'os',\n#     'path': None,\n#     'category': ImportType.Native,\n#     'code': 'import os',\n# }\n</code></pre> <p>:param imported_identifier: The name of the lib, mod or element imported.</p> <p>:type imported_identifier: ImportedIdentifier</p> <p>:return: A standardized dictionary representing the import statement.</p> <p>:rtype: list[StandardReturn]</p> Snippet Python<pre><code>def __handle_import(imported_identifier: ImportedIdentifier) -&gt; StandardReturn:\n    \"\"\"\n    Constructs a standardized dictionary representation for an import statement.\n\n    This function processes the given library name, determines its import category\n    (local, native, or third-party), and builds a standardized dictionary structure\n    representing the import statement. The resulting data includes information about\n    the statement type, library name, import category, and the generated import code.\n\n    Key concepts:\n    - Import Categorization: Determines whether the library is native (built-in),\n      third-party, or local.\n    - Standardized Structure: Returns a dictionary conforming to the `StandardReturn`\n      format, ensuring consistency across codebase documentation.\n    - Dynamic Code Generation: Constructs the import statement dynamically based on\n      the library name.\n\n    Example:\n\n    ```python\n    data: StandardReturn = __handle_import('os')\n    data\n    # {\n    #     'statement': Statement.Import,\n    #     'name': 'os',\n    #     'path': None,\n    #     'category': ImportType.Native,\n    #     'code': 'import os',\n    # }\n    ```\n\n    :param imported_identifier: The name of the lib, mod or element imported.\n    :type imported_identifier: ImportedIdentifier\n    :return: A standardized dictionary representing the import statement.\n    :rtype: list[StandardReturn]\n    \"\"\"\n    statement: Final[Statement] = Statement.Import\n    path: Final[None] = None\n    category: ImportType = get_import_type(imported_identifier)\n    contract: ImportContract = ImportContract(statement=statement, name=imported_identifier, path=path, category=category, code=f'import {imported_identifier}')\n    data: StandardReturn = standard_struct()\n    data.update(contract._asdict())\n    return data\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#def-_handle_import","title":"<code>def _handle_import</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturn], node: ast.Import</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>list[StandardReturn]</code></p> Docstring <p>Updates a standard structure with information from an import statement node.</p> <p>This function processes an AST import node, extracts the library names being imported, and updates the given <code>StandardReturn</code> structure with details about each library. It leverages the <code>__handle_import</code> function to standardize the data for each imported library.</p> <p>Key concepts: - AST Parsing: Processes Python's AST nodes for import statements. - Data Standardization: Utilizes <code>__handle_import</code> to format each import into a   consistent structure. - Structure Update: Modifies the provided <code>struct</code> in-place with import data.</p> <p>Example:</p> Python<pre><code>import ast\n\nnode: ast.AST = ast.parse('import os, sys').body[0]\nupdated_struct: list[StandardReturn] = _handle_import([], node)\nupdated_struct\n# Outputs standardized data for `os` and `sys` imports.\n</code></pre> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturn]</p> <p>:param node: The AST node representing an import statement.</p> <p>:type node: ast.Import</p> <p>:return: The updated structure with information about the imported libraries.</p> <p>:rtype: list[StandardReturn]</p> Snippet Python<pre><code>def _handle_import(struct: list[StandardReturn], node: ast.Import) -&gt; list[StandardReturn]:\n    \"\"\"\n    Updates a standard structure with information from an import statement node.\n\n    This function processes an AST import node, extracts the library names being\n    imported, and updates the given `StandardReturn` structure with details about\n    each library. It leverages the `__handle_import` function to standardize the data\n    for each imported library.\n\n    Key concepts:\n    - AST Parsing: Processes Python's AST nodes for import statements.\n    - Data Standardization: Utilizes `__handle_import` to format each import into a\n      consistent structure.\n    - Structure Update: Modifies the provided `struct` in-place with import data.\n\n    Example:\n\n    ```python\n    import ast\n\n    node: ast.AST = ast.parse('import os, sys').body[0]\n    updated_struct: list[StandardReturn] = _handle_import([], node)\n    updated_struct\n    # Outputs standardized data for `os` and `sys` imports.\n    ```\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturn]\n    :param node: The AST node representing an import statement.\n    :type node: ast.Import\n    :return: The updated structure with information about the imported libraries.\n    :rtype: list[StandardReturn]\n    \"\"\"\n    for lib in [i.name for i in node.names]:\n        struct.append(__handle_import(lib))\n    return struct\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#def-_handle_import_from","title":"<code>def _handle_import_from</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturn], node: ast.ImportFrom</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>list[StandardReturn]</code></p> Docstring <p>Processes an <code>ast.ImportFrom</code> node and returns its data.</p> <p>This function iterates over the imported module names within an <code>ast.ImportFrom</code> node, classifying each module into one of the following categorys, as <code>handle_import</code>: - Native: The module is a built-in Python module. - Third-Party: The module is installed via external libraries. - Local: The module is neither built-in nor a third-party library, problably local.</p> <p>Each module's data includes its path and category, stored in a structured dict.</p> <p>Example:</p> Python<pre><code>import ast\n\nnode: ast.AST = ast.parse('from os import environ').body[0]\nupdated_struct: list[StandardReturn] = _handle_import_from([], node)\nupdated_struct\n# Outputs standardized data for `environ` with `os` as path.\n</code></pre> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturn]</p> <p>:param node: The AST node representing an import statement.</p> <p>:type node: ast.ImportFrom</p> <p>:return: A dict containing the statement type and categorized module information.</p> <p>:rtype: list[StandardReturn]</p> Snippet Python<pre><code>def _handle_import_from(struct: list[StandardReturn], node: ast.ImportFrom) -&gt; list[StandardReturn]:\n    \"\"\"\n    Processes an `ast.ImportFrom` node and returns its data.\n\n    This function iterates over the imported module names within an `ast.ImportFrom`\n    node, classifying each module into one of the following categorys, as\n    `handle_import`:\n    - Native: The module is a built-in Python module.\n    - Third-Party: The module is installed via external libraries.\n    - Local: The module is neither built-in nor a third-party library, problably local.\n\n    Each module's data includes its path and category, stored in a structured dict.\n\n    Example:\n\n    ```python\n    import ast\n\n    node: ast.AST = ast.parse('from os import environ').body[0]\n    updated_struct: list[StandardReturn] = _handle_import_from([], node)\n    updated_struct\n    # Outputs standardized data for `environ` with `os` as path.\n    ```\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturn]\n    :param node: The AST node representing an import statement.\n    :type node: ast.ImportFrom\n    :return: A dict containing the statement type and categorized module information.\n    :rtype: list[StandardReturn]\n    \"\"\"\n    statement: Final[Statement] = Statement.ImportFrom\n    names: Final[list[ImportedIdentifier]] = [i.name for i in node.names]\n    path: Final[ModulePath | None] = node.module\n    category: ImportType = ImportType.Local\n    code: Final[CodeSnippet] = ast.unparse(node)\n    if bin(f'{path}.'.split('.')[0], BUILTIN_MODULES):\n        category = ImportType.Native\n    elif get_import_type(str(path)):\n        category = ImportType.TrdParty\n    for i in names:\n        contract: ImportFromContract = ImportFromContract(statement=statement, name=i, path=path, category=category, code=code)\n        data: StandardReturn = standard_struct()\n        data.update(contract._asdict())\n        struct.append(data)\n    return struct\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#def-_handle_assign","title":"<code>def _handle_assign</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturn], node: ast.Assign</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>list[StandardReturn]</code></p> Docstring <p>Processes an <code>ast.Assign</code> node and returns its data.</p> <p>This function analyzes the components of an assignment, including the target vars and the assigned value, returning a structured dict with the extracted details.</p> <p>Key elements of the returned data: - tokens: A list of string repr for all target variables in the assignment. - value: A string repr of the value being assigned.</p> <p>Example:</p> Python<pre><code>import ast\n\nnode: ast.AST = ast.parse('num = 33').body[0]\nupdated_struct: list[StandardReturn] = _handle_assign([], node)\nupdated_struct\n# Outputs standardized data for `num` definition.\n</code></pre> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturn]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.Assign</p> <p>:return: A dict containing the statement type, target variables, and assigned value.</p> <p>:rtype: list[StandardReturn]</p> Snippet Python<pre><code>def _handle_assign(struct: list[StandardReturn], node: ast.Assign) -&gt; list[StandardReturn]:\n    \"\"\"\n    Processes an `ast.Assign` node and returns its data.\n\n    This function analyzes the components of an assignment, including the target vars\n    and the assigned value, returning a structured dict with the extracted details.\n\n    Key elements of the returned data:\n    - tokens: A list of string repr for all target variables in the assignment.\n    - value: A string repr of the value being assigned.\n\n    Example:\n\n    ```python\n    import ast\n\n    node: ast.AST = ast.parse('num = 33').body[0]\n    updated_struct: list[StandardReturn] = _handle_assign([], node)\n    updated_struct\n    # Outputs standardized data for `num` definition.\n    ```\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturn]\n    :param node: The AST node representing the node statement.\n    :type node: ast.Assign\n    :return: A dict containing the statement type, target variables, and assigned value.\n    :rtype: list[StandardReturn]\n    \"\"\"\n    statement: Final[Statement] = Statement.Assign\n    tokens: Final[list[Token]] = [_handle_node(i)[0] for i in node.targets]\n    value: Final[Value] = _handle_node(node.value)[0]\n    code: Final[CodeSnippet] = ast.unparse(node)\n    contract: AssignContract = AssignContract(statement=statement, tokens=tokens, value=value, code=code)\n    data: StandardReturn = standard_struct()\n    data.update(contract._asdict())\n    struct.append(data)\n    return struct\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#def-_handle_annassign","title":"<code>def _handle_annassign</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturn], node: ast.AnnAssign</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>list[StandardReturn]</code></p> Docstring <p>Processes an <code>ast.AnnAssign</code> node and returns its data.</p> <p>This function analyzes the components of an assignment, including the target var and the assigned value, plus the typing annotation, returning a structured dict with the extracted details.</p> <p>Key elements of the returned data: - token: A string repr for the target var in the assignment. - value: A string repr of the value being assigned. - annot: The type hint for the assignment.</p> <p>Example:</p> Python<pre><code>import ast\n\nnode: ast.AST = ast.parse('num: int = 33').body[0]\nupdated_struct: list[StandardReturn] = _handle_anassign([], node)\nupdated_struct\n# Outputs standardized data for `num` definition with `int` annotation.\n</code></pre> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturn]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.AnnAssign</p> <p>:return: A dict with the statement type, target var, type hint and assigned value.</p> <p>:rtype: list[StandardReturn]</p> Snippet Python<pre><code>def _handle_annassign(struct: list[StandardReturn], node: ast.AnnAssign) -&gt; list[StandardReturn]:\n    \"\"\"\n    Processes an `ast.AnnAssign` node and returns its data.\n\n    This function analyzes the components of an assignment, including the target var\n    and the assigned value, plus the typing annotation, returning a structured dict with\n    the extracted details.\n\n    Key elements of the returned data:\n    - token: A string repr for the target var in the assignment.\n    - value: A string repr of the value being assigned.\n    - annot: The type hint for the assignment.\n\n    Example:\n\n    ```python\n    import ast\n\n    node: ast.AST = ast.parse('num: int = 33').body[0]\n    updated_struct: list[StandardReturn] = _handle_anassign([], node)\n    updated_struct\n    # Outputs standardized data for `num` definition with `int` annotation.\n    ```\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturn]\n    :param node: The AST node representing the node statement.\n    :type node: ast.AnnAssign\n    :return: A dict with the statement type, target var, type hint and assigned value.\n    :rtype: list[StandardReturn]\n    \"\"\"\n    statement: Statement = Statement.AnnAssign\n    name: Token = _handle_node(node.target)[0]\n    annot: Annotation = _handle_node(node.annotation)[0]\n    value: Value = _handle_node(node.value)[0] if node.value else ''\n    code: CodeSnippet = ast.unparse(node)\n    contract: AnnAssignContract = AnnAssignContract(statement=statement, name=name, annot=annot, value=value, code=code)\n    data: StandardReturn = standard_struct()\n    data.update(contract._asdict())\n    struct.append(data)\n    return struct\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#def-__format_arg","title":"<code>def __format_arg</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>name: Token, annotation: Annotation | None, default: DefaultValue | None</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>Args</code></p> Docstring <p>Formats a function argument into a string repr with optional type annotations and default values.</p> <p>This function constructs a f-string representing a function argument, including its name, optional type annotation, and default value. It ensures consistent formatting for use in function signatures or documentation.</p> <p>Key concepts: - Type Annotations: Adds type annotations if provided. - Default Values: Appends default values where applicable. - Fallback Handling: If neither an annotation nor a default value is present, it   defaults to 'Unknown'.</p> <p>Example:</p> Python<pre><code>formatted: Args = __format_arg('param', 'int', '42')\nformatted\n# \"param: int = 42\"\n</code></pre> <p>:param name: The name of the argument.</p> <p>:type name: Token</p> <p>:param annotation: The type annotation for the argument, if any.</p> <p>:type annotation: Annotation | None</p> <p>:param default: The default value of the argument, if any.</p> <p>:type default: DefaultValue | None</p> <p>:return: A formatted string representing the argument.</p> <p>:rtype: Args</p> Snippet Python<pre><code>def __format_arg(name: Token, annotation: Annotation | None, default: DefaultValue | None) -&gt; Args:\n    \"\"\"\n    Formats a function argument into a string repr with optional type annotations and\n    default values.\n\n    This function constructs a f-string representing a function argument, including its\n    name, optional type annotation, and default value. It ensures consistent formatting\n    for use in function signatures or documentation.\n\n    Key concepts:\n    - Type Annotations: Adds type annotations if provided.\n    - Default Values: Appends default values where applicable.\n    - Fallback Handling: If neither an annotation nor a default value is present, it\n      defaults to 'Unknown'.\n\n    Example:\n\n    ```python\n    formatted: Args = __format_arg('param', 'int', '42')\n    formatted\n    # \"param: int = 42\"\n    ```\n\n    :param name: The name of the argument.\n    :type name: Token\n    :param annotation: The type annotation for the argument, if any.\n    :type annotation: Annotation | None\n    :param default: The default value of the argument, if any.\n    :type default: DefaultValue | None\n    :return: A formatted string representing the argument.\n    :rtype: Args\n    \"\"\"\n    if annotation and default:\n        return f'{name}: {annotation} = {default}'\n    elif annotation:\n        return f'{name}: {annotation}'\n    elif default:\n        return f'{name} = {default}'\n    else:\n        return f'{name}: Unknown'\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#def-__process_function_args","title":"<code>def __process_function_args</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>node_args: ast.arguments</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>str</code></p> Docstring <p>Processes and formats positional arguments from a function definition.</p> <p>This function extracts positional arguments from an <code>ast.arguments</code> node, including their names, optional type annotations, and default values. It formats them into a single, comma-separated string repr suitable for documentation or code generation.</p> <p>Key concepts: - Positional Argsuments: Handles arguments that can be passed by position. - Type Annotations: Extracts and formats type annotations, if present. - Default Values: Aligns each argument with its default value, if provided.</p> <p>Example:</p> Python<pre><code>import ast\n\nsource: str = \"def example(a: int, b: str = 'default'): pass\"\nnode: ast.AST = ast.parse(source).body[0]\nformatted: str = __process_function_args(node.args)\nformatted\n# \"a: int, b: str = 'default'\"\n</code></pre> <p>:param node_args: The <code>arguments</code> node from an AST function definition.</p> <p>:type node_args: ast.arguments</p> <p>:return: A comma-separated string of formatted positional arguments.</p> <p>:rtype: str</p> Snippet Python<pre><code>def __process_function_args(node_args: ast.arguments) -&gt; str:\n    \"\"\"\n    Processes and formats positional arguments from a function definition.\n\n    This function extracts positional arguments from an `ast.arguments` node,\n    including their names, optional type annotations, and default values.\n    It formats them into a single, comma-separated string repr suitable\n    for documentation or code generation.\n\n    Key concepts:\n    - Positional Argsuments: Handles arguments that can be passed by position.\n    - Type Annotations: Extracts and formats type annotations, if present.\n    - Default Values: Aligns each argument with its default value, if provided.\n\n    Example:\n\n    ```python\n    import ast\n\n    source: str = \"def example(a: int, b: str = 'default'): pass\"\n    node: ast.AST = ast.parse(source).body[0]\n    formatted: str = __process_function_args(node.args)\n    formatted\n    # \"a: int, b: str = 'default'\"\n    ```\n\n    :param node_args: The `arguments` node from an AST function definition.\n    :type node_args: ast.arguments\n    :return: A comma-separated string of formatted positional arguments.\n    :rtype: str\n    \"\"\"\n    formatted_args: list[Args] = []\n    for i, arg in enumerate(node_args.args):\n        name: Token = arg.arg\n        annotation: Annotation | None = _handle_node(arg.annotation)[0] if arg.annotation else None\n        default: DefaultValue | None = None\n        if i &lt; len(node_args.kw_defaults):\n            default_node = node_args.kw_defaults[i]\n            if default_node:\n                default = _handle_node(default_node)[0]\n        formatted_args.append(__format_arg(name, annotation, default))\n    return ', '.join(formatted_args)\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#def-__process_function_kwargs","title":"<code>def __process_function_kwargs</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>node_args: ast.arguments</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>str</code></p> Docstring <p>Processes and formats keyword-only arguments from a function definition.</p> <p>This function extracts keyword-only arguments from an <code>ast.arguments</code> node, including their names, optional type annotations, and default values. It formats them into a single, comma-separated string repr suitable for documentation or code generation.</p> <p>Key concepts: - Keyword-only Argsuments: Processes arguments that must be passed by keyword. - Type Annotations: Extracts and formats type annotations if present. - Default Values: Handles default values, aligning them with their own arguments.</p> <p>Example:</p> Python<pre><code>import ast\n\nsource: str = 'def example(*, debug: bool = True): pass'\nnode: ast.AST = ast.parse(source).body[0]\nformatted: str = __process_function_kwargs(node.args)\nformatted\n# \"debug: bool = True\"\n</code></pre> <p>:param node_args: The <code>arguments</code> node from an AST function definition.</p> <p>:type node_args: ast.arguments</p> <p>:return: A comma-separated string of formatted keyword-only arguments.</p> <p>:rtype: str</p> Snippet Python<pre><code>def __process_function_kwargs(node_args: ast.arguments) -&gt; str:\n    \"\"\"\n    Processes and formats keyword-only arguments from a function definition.\n\n    This function extracts keyword-only arguments from an `ast.arguments` node,\n    including their names, optional type annotations, and default values. It formats\n    them into a single, comma-separated string repr suitable for documentation\n    or code generation.\n\n    Key concepts:\n    - Keyword-only Argsuments: Processes arguments that must be passed by keyword.\n    - Type Annotations: Extracts and formats type annotations if present.\n    - Default Values: Handles default values, aligning them with their own arguments.\n\n    Example:\n\n    ```python\n    import ast\n\n    source: str = 'def example(*, debug: bool = True): pass'\n    node: ast.AST = ast.parse(source).body[0]\n    formatted: str = __process_function_kwargs(node.args)\n    formatted\n    # \"debug: bool = True\"\n    ```\n\n    :param node_args: The `arguments` node from an AST function definition.\n    :type node_args: ast.arguments\n    :return: A comma-separated string of formatted keyword-only arguments.\n    :rtype: str\n    \"\"\"\n    formatted_kwargs: list[str] = []\n    for i, arg in enumerate(node_args.kwonlyargs):\n        name: Kwargs = arg.arg\n        annotation: Annotation | None = _handle_node(arg.annotation)[0] if arg.annotation else None\n        default: DefaultValue | None = None\n        if i &lt; len(node_args.kw_defaults):\n            default_node = node_args.kw_defaults[i]\n            if default_node:\n                default = _handle_node(default_node)[0]\n        formatted_kwargs.append(__format_arg(name, annotation, default))\n    return ', '.join(formatted_kwargs)\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#def-__process_function_type","title":"<code>def __process_function_type</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>node: ast.FunctionDef, is_from_class: bool</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>FunctionType</code></p> Docstring <p>Determines the type of a function based on its context and structure.</p> <p>This function identifies whether a given function node from the AST is a method, a generator, or a regular function.</p> <ul> <li>If is within a class or matches a dunder method name, it returns a <code>Method</code>.</li> <li>Elif contains a <code>yield</code> type statements, it returns a <code>Generator</code>.</li> <li>Otherwise, it returns a <code>Function</code>.</li> </ul> <p>:param node: The AST node representing the function.</p> <p>:type node: ast.FunctionDef</p> <p>:param is_from_class: Indicates if the function is defined within a class.</p> <p>:type is_from_class: bool</p> <p>:return: The type of the function (<code>Method</code>, <code>Generator</code>, or <code>Function</code>).</p> <p>:rtype: FunctionType</p> Snippet Python<pre><code>def __process_function_type(node: ast.FunctionDef, is_from_class: bool) -&gt; FunctionType:\n    \"\"\"\n    Determines the type of a function based on its context and structure.\n\n    This function identifies whether a given function node from the AST is a method,\n    a generator, or a regular function.\n\n    - If is within a class or matches a dunder method name, it returns a `Method`.\n    - Elif contains a `yield` type statements, it returns a `Generator`.\n    - Otherwise, it returns a `Function`.\n\n    :param node: The AST node representing the function.\n    :type node: ast.FunctionDef\n    :param is_from_class: Indicates if the function is defined within a class.\n    :type is_from_class: bool\n    :return: The type of the function (`Method`, `Generator`, or `Function`).\n    :rtype: FunctionType\n    \"\"\"\n    if is_from_class or bin(node.name, BUILTIN_DUNDER_METHODS):\n        return FunctionType.Method\n    elif any((isinstance(n, ast.Yield | ast.YieldFrom) for n in ast.walk(node))):\n        return FunctionType.Generator\n    return FunctionType.Function\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#def-_handle_function_def","title":"<code>def _handle_function_def</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturn], node: ast.FunctionDef, is_from_class: bool</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>list[StandardReturn]</code></p> Docstring <p>Processes an <code>ast.FunctionDef</code> node and returns its data.</p> <p>This function analyzes the components of a func def, mapping the name, decorators, arguments (name, type, default value), return type and even the type of function it is: - Function: a base function, simply defined using <code>def</code> keyword. - Method: also base function, but defined inside a class (e.g. <code>def __init__():</code>). - Generator: process an iterable object at a time, on demand, with <code>yield</code> inside.</p> <p>Example:</p> Python<pre><code>import ast\n\nnode: ast.AST = ast.parse('def foo(*args: Any): pass').body[0]\nupdated_struct: list[StandardReturn] = _handle_function_def([], node)\nupdated_struct\n# Outputs standardized data for `foo` definition.\n</code></pre> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturn]</p> <p>:param node: The AST node representing a func def statement.</p> <p>:type node: ast.FunctionDef</p> <p>:param is_from_class: The arg who tells if shoud be directly defined as a Method.</p> <p>:type is_from_class: bool = False</p> <p>:return: A dict containing the statement type and the data listed before.</p> <p>:rtype: list[StandardReturn]</p> Snippet Python<pre><code>def _handle_function_def(struct: list[StandardReturn], node: ast.FunctionDef, is_from_class: bool=False) -&gt; list[StandardReturn]:\n    \"\"\"\n    Processes an `ast.FunctionDef` node and returns its data.\n\n    This function analyzes the components of a func def, mapping the name, decorators,\n    arguments (name, type, default value), return type and even the type of function it\n    is:\n    - Function: a base function, simply defined using `def` keyword.\n    - Method: also base function, but defined inside a class (e.g. `def __init__():`).\n    - Generator: process an iterable object at a time, on demand, with `yield` inside.\n\n    Example:\n\n    ```python\n    import ast\n\n    node: ast.AST = ast.parse('def foo(*args: Any): pass').body[0]\n    updated_struct: list[StandardReturn] = _handle_function_def([], node)\n    updated_struct\n    # Outputs standardized data for `foo` definition.\n    ```\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturn]\n    :param node: The AST node representing a func def statement.\n    :type node: ast.FunctionDef\n    :param is_from_class: The arg who tells if shoud be directly defined as a Method.\n    :type is_from_class: bool = False\n    :return: A dict containing the statement type and the data listed before.\n    :rtype: list[StandardReturn]\n    \"\"\"\n    statement: Final[Statement] = Statement.FunctionDef\n    name: Final[Token] = node.name\n    docstring: Final[Docstring | None] = ast.get_docstring(node)\n    decos: Final[list[Decorator]] = [_handle_node(i)[0] for i in node.decorator_list]\n    rtype: Final[Annotation | None] = _handle_node(node.returns)[0] if node.returns else None\n    code: Final[CodeSnippet] = ast.unparse(node)\n    args_str: Final[Args] = __process_function_args(node.args)\n    kwargs_str: Final[Kwargs] = __process_function_kwargs(node.args)\n    category: Final[FunctionType] = __process_function_type(node, is_from_class)\n    contract: FunctionDefContract = FunctionDefContract(statement=statement, name=name, category=category, docstring=docstring, decorators=decos, rtype=rtype, args=args_str, kwargs=kwargs_str, code=code)\n    data: StandardReturn = standard_struct()\n    data.update(contract._asdict())\n    struct.append(data)\n    return struct\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#def-_handle_async_function_def","title":"<code>def _handle_async_function_def</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturn], node: ast.AsyncFunctionDef</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>list[StandardReturn]</code></p> Docstring <p>Processes an <code>ast.AsyncFunctionDef</code> node and returns its data.</p> <p>This function analyzes the components of a func def, mapping the name, decorators, arguments (name, type, default value), return type and even the type of function it is, which in this case can be only one: - Coroutine: An async func, defined with <code>async def</code> syntax...</p> <p>Example:</p> Python<pre><code>import ast\n\nnode: ast.AST = ast.parse('async def foo(*args: Any): pass').body[0]\nupdated_struct: list[StandardReturn] = _handle_assign([], node)\nupdated_struct\n# Outputs standardized data for async `foo` definition.\n</code></pre> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturn]</p> <p>:param node: The AST node representing a func def statement.</p> <p>:type node: ast.AsyncFunctionDef</p> <p>:return: A dict containing the statement type and the data listed before.</p> <p>:rtype: list[StandardReturn]</p> Snippet Python<pre><code>def _handle_async_function_def(struct: list[StandardReturn], node: ast.AsyncFunctionDef) -&gt; list[StandardReturn]:\n    \"\"\"\n    Processes an `ast.AsyncFunctionDef` node and returns its data.\n\n    This function analyzes the components of a func def, mapping the name, decorators,\n    arguments (name, type, default value), return type and even the type of function it\n    is, which in this case can be only one:\n    - Coroutine: An async func, defined with `async def` syntax...\n\n    Example:\n\n    ```python\n    import ast\n\n    node: ast.AST = ast.parse('async def foo(*args: Any): pass').body[0]\n    updated_struct: list[StandardReturn] = _handle_assign([], node)\n    updated_struct\n    # Outputs standardized data for async `foo` definition.\n    ```\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturn]\n    :param node: The AST node representing a func def statement.\n    :type node: ast.AsyncFunctionDef\n    :return: A dict containing the statement type and the data listed before.\n    :rtype: list[StandardReturn]\n    \"\"\"\n    statement: Final[Statement] = Statement.AsyncFunctionDef\n    name: Final[Token] = node.name\n    docstring: Final[Docstring | None] = ast.get_docstring(node)\n    decos: Final[list[Decorator]] = [_handle_node(i)[0] for i in node.decorator_list]\n    rtype: Final[Annotation | None] = _handle_node(node.returns)[0] if node.returns else None\n    code: Final[CodeSnippet] = ast.unparse(node)\n    args_str: Final[Args] = __process_function_args(node.args)\n    kwargs_str: Final[Kwargs] = __process_function_kwargs(node.args)\n    contract: AsyncFunctionDefContract = AsyncFunctionDefContract(statement=statement, name=name, category=FunctionType.Coroutine, docstring=docstring, decorators=decos, rtype=rtype, args=args_str, kwargs=kwargs_str, code=code)\n    data: StandardReturn = standard_struct()\n    data.update(contract._asdict())\n    struct.append(data)\n    return struct\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#def-__format_class_kwarg","title":"<code>def __format_class_kwarg</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>name: str | None, value: ast.expr</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>str</code></p> Docstring <p>Formats a kwarg from a class definition into a string repr.</p> <p>This function converts an AST kwarg into a string, representing it in the format <code>name=value</code>. If the keyword has no name (e.g., for positional arguments), only the value is returned.</p> <p>Key concepts: - AST Unparsing: Uses <code>ast.unparse</code> to convert an AST expression into its   corresponding Python code as a string. - Conditional Formatting: Handles named and unnamed (positional) keyword arguments.</p> <p>Example:</p> Python<pre><code>import ast\n\nkwarg: ast.keyword = ast.keyword(arg='debug', value=ast.Constant(value=True))\nformatted: str = __format_class_kwarg(kwarg.arg, kwarg.value)\nformatted\n# \"debug = True\"\n</code></pre> <p>:param name: The name of the kwarg (can be <code>None</code> for positional arguments).</p> <p>:type name: str | None</p> <p>:param value: The AST expression representing the value of the keyword argument.</p> <p>:type value: ast.expr</p> <p>:return: A formatted string representing the keyword argument.</p> <p>:rtype: str</p> Snippet Python<pre><code>def __format_class_kwarg(name: str | None, value: ast.expr) -&gt; str:\n    \"\"\"\n    Formats a kwarg from a class definition into a string repr.\n\n    This function converts an AST kwarg into a string, representing it in the format\n    `name=value`. If the keyword has no name (e.g., for positional arguments), only the\n    value is returned.\n\n    Key concepts:\n    - AST Unparsing: Uses `ast.unparse` to convert an AST expression into its\n      corresponding Python code as a string.\n    - Conditional Formatting: Handles named and unnamed (positional) keyword arguments.\n\n    Example:\n\n    ```python\n    import ast\n\n    kwarg: ast.keyword = ast.keyword(arg='debug', value=ast.Constant(value=True))\n    formatted: str = __format_class_kwarg(kwarg.arg, kwarg.value)\n    formatted\n    # \"debug = True\"\n    ```\n\n    :param name: The name of the kwarg (can be `None` for positional arguments).\n    :type name: str | None\n    :param value: The AST expression representing the value of the keyword argument.\n    :type value: ast.expr\n    :return: A formatted string representing the keyword argument.\n    :rtype: str\n    \"\"\"\n    value_str: str = ast.unparse(value)\n    if name:\n        return f'{name} = {value_str}'\n    return value_str\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#def-__process_class_kwargs","title":"<code>def __process_class_kwargs</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>keywords: list[ast.keyword]</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>str</code></p> Docstring <p>Processes and formats keyword arguments from a class definition.</p> <p>This function takes a list of keyword arguments (from an AST node) and formats them into a single, comma-separated string. Each keyword is processed using the <code>__format_class_kwarg</code> function to ensure consistent repr.</p> <p>Key concepts: - Keyword Formatting: Converts each kwarg into a string repr   of the form <code>key=value</code>. - List Processing: Aggregates and joins all formatted keyword arguments into a   single string for use in documentation or code generation.</p> <p>Example:</p> Python<pre><code>import ast\n\nkeywords: list[ast.keyword] = [\n    ast.keyword(arg='name', value=ast.Constant(value='MyClass'))\n]\nformatted: str = __process_class_kwargs(keywords)\nformatted\n# \"name='MyClass'\"\n</code></pre> <p>:param keywords: A list of AST keyword arguments.</p> <p>:type keywords: list[ast.keyword]</p> <p>:return: A comma-separated string of formatted keyword arguments.</p> <p>:rtype: str</p> Snippet Python<pre><code>def __process_class_kwargs(keywords: list[ast.keyword]) -&gt; str:\n    \"\"\"\n    Processes and formats keyword arguments from a class definition.\n\n    This function takes a list of keyword arguments (from an AST node) and formats\n    them into a single, comma-separated string. Each keyword is processed using\n    the `__format_class_kwarg` function to ensure consistent repr.\n\n    Key concepts:\n    - Keyword Formatting: Converts each kwarg into a string repr\n      of the form `key=value`.\n    - List Processing: Aggregates and joins all formatted keyword arguments into a\n      single string for use in documentation or code generation.\n\n    Example:\n\n    ```python\n    import ast\n\n    keywords: list[ast.keyword] = [\n        ast.keyword(arg='name', value=ast.Constant(value='MyClass'))\n    ]\n    formatted: str = __process_class_kwargs(keywords)\n    formatted\n    # \"name='MyClass'\"\n    ```\n\n    :param keywords: A list of AST keyword arguments.\n    :type keywords: list[ast.keyword]\n    :return: A comma-separated string of formatted keyword arguments.\n    :rtype: str\n    \"\"\"\n    formatted_kwargs: list[str] = [__format_class_kwarg(kw.arg, kw.value) for kw in keywords]\n    return ', '.join(formatted_kwargs)\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#def-_handle_class_def","title":"<code>def _handle_class_def</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturn], node: ast.ClassDef</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>list[StandardReturn]</code></p> Docstring <p>Processes an <code>ast.ClassDef</code> node and returns its data.</p> <p>This function analyzes the components of a class definition, including its name, base classes, decorators, and keyword arguments, returning a structured dict with the extracted details.</p> <p>Key elements of the returned data: - name: The name of the class as a string. - parents: A list of string reprs for the base classes of the class. - decos: A list of string reprs for all decorators applied to the class. - kwargs: A list of tuples, in <code>(name, value)</code> style.</p> <p>Example:</p> Python<pre><code>import ast\n\nnode: ast.AST = ast.parse('class Foo: pass').body[0]\nupdated_struct: list[StandardReturn] = _handle_class_def([], node)\nupdated_struct\n# Outputs standardized data for `Foo` definition.\n</code></pre> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturn]</p> <p>:param node: The AST node representing a class definition.</p> <p>:type node: ast.ClassDef</p> <p>:return: A dict with the statement type, name, base classes, decorators, and kwargs.</p> <p>:rtype: list[StandardReturn]</p> Snippet Python<pre><code>def _handle_class_def(struct: list[StandardReturn], node: ast.ClassDef) -&gt; list[StandardReturn]:\n    \"\"\"\n    Processes an `ast.ClassDef` node and returns its data.\n\n    This function analyzes the components of a class definition, including its name,\n    base classes, decorators, and keyword arguments, returning a structured dict with\n    the extracted details.\n\n    Key elements of the returned data:\n    - name: The name of the class as a string.\n    - parents: A list of string reprs for the base classes of the class.\n    - decos: A list of string reprs for all decorators applied to the class.\n    - kwargs: A list of tuples, in `(name, value)` style.\n\n    Example:\n\n    ```python\n    import ast\n\n    node: ast.AST = ast.parse('class Foo: pass').body[0]\n    updated_struct: list[StandardReturn] = _handle_class_def([], node)\n    updated_struct\n    # Outputs standardized data for `Foo` definition.\n    ```\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturn]\n    :param node: The AST node representing a class definition.\n    :type node: ast.ClassDef\n    :return: A dict with the statement type, name, base classes, decorators, and kwargs.\n    :rtype: list[StandardReturn]\n    \"\"\"\n    statement: Final[Statement] = Statement.ClassDef\n    name: Final[Token] = node.name\n    docstring: Final[Docstring | None] = ast.get_docstring(node)\n    inheritance: Final[list[Inheritance]] = [_handle_node(i)[0] for i in node.bases if isinstance(i, ast.Name)]\n    decos: Final[list[Decorator]] = [_handle_node(i)[0] for i in node.decorator_list]\n    kwargs_str: Kwargs = __process_class_kwargs(node.keywords)\n    code: Final[CodeSnippet] = ast.unparse(node)\n    contract: ClassDefContract = ClassDefContract(statement=statement, name=name, docstring=docstring, inheritance=inheritance, decorators=decos, kwargs=kwargs_str, code=code)\n    data: StandardReturn = standard_struct()\n    data.update(contract._asdict())\n    struct.append(data)\n    for child in node.body:\n        if isinstance(child, ast.FunctionDef):\n            function_data: StandardReturn = standard_struct()\n            function_data.update(_handle_function_def([], child, is_from_class=True)[0])\n            struct.append(function_data)\n    return struct\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#def-_handle_assert","title":"<code>def _handle_assert</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturn], node: ast.Assert</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>list[StandardReturn]</code></p> Docstring <p>Processes an <code>ast.Assert</code> node and returns its data.</p> <p>This function analyzes the components of an assertion, including the expression of the test and the optional message, returning a structured dict with the extracted details.</p> <p>Key elements of the returned data: - statement: The type of statement, identified as <code>Statement.Assert</code>. - test: A repr of the test expression being asserted. - msg: A string repr of the optional message, <code>None</code> if no message is provided.</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturn]</p> <p>:param node: The AST node representing an assertion statement.</p> <p>:type node: ast.Assert</p> <p>:return: A dict with the statement type, test expression, and optional message.</p> <p>:rtype: list[StandardReturn]</p> Snippet Python<pre><code>def _handle_assert(struct: list[StandardReturn], node: ast.Assert) -&gt; list[StandardReturn]:\n    \"\"\"\n    Processes an `ast.Assert` node and returns its data.\n\n    This function analyzes the components of an assertion, including the expression of\n    the test and the optional message, returning a structured dict with the extracted\n    details.\n\n    Key elements of the returned data:\n    - statement: The type of statement, identified as `Statement.Assert`.\n    - test: A repr of the test expression being asserted.\n    - msg: A string repr of the optional message, `None` if no message is provided.\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturn]\n    :param node: The AST node representing an assertion statement.\n    :type node: ast.Assert\n    :return: A dict with the statement type, test expression, and optional message.\n    :rtype: list[StandardReturn]\n    \"\"\"\n    statement: Final[Statement] = Statement.Assert\n    test: Final[AssertionTest] = _handle_node(node.test)[0]\n    msg: Final[AssertionMessage | None] = _handle_node(node.msg)[0] if node.msg else None\n    code: Final[CodeSnippet] = ast.unparse(node)\n    contract: AssertContract = AssertContract(statement=statement, test=test, msg=msg, code=code)\n    data: StandardReturn = standard_struct()\n    data.update(contract._asdict())\n    struct.append(data)\n    return struct\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#def-_mark_methods","title":"<code>def _mark_methods</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>node: ast.ClassDef</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>None</code></p> Docstring <p>Marks all functions within a given <code>ClassDef</code> node as methods.</p> <p>This function iterates over the child nodes of the provided class node, and for each method (a <code>FunctionDef</code>), it assigns the class type (<code>ast.ClassDef</code>) to the <code>parent</code> attribute of the method node.</p> <p>:param node: The class definition node containing methods to be marked.</p> <p>:type node: ast.ClassDef</p> <p>:return: None</p> <p>:rtype: None</p> Snippet Python<pre><code>def _mark_methods(node: ast.ClassDef) -&gt; None:\n    \"\"\"\n    Marks all functions within a given `ClassDef` node as methods.\n\n    This function iterates over the child nodes of the provided class node, and\n    for each method (a `FunctionDef`), it assigns the class type (`ast.ClassDef`)\n    to the `parent` attribute of the method node.\n\n    :param node: The class definition node containing methods to be marked.\n    :type node: ast.ClassDef\n    :return: None\n    :rtype: None\n    \"\"\"\n    for child_node in ast.iter_child_nodes(node):\n        if isinstance(child_node, ast.FunctionDef):\n            setattr(child_node, 'parent', ast.ClassDef)\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#def-wrapped_mark_methods_for_testing","title":"<code>def wrapped_mark_methods_for_testing</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>node: ast.ClassDef</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>None</code></p> Docstring <p>Just encapsulates <code>_mark_methods</code> function, just for unittesting.</p> <p>:param node: The class definition node containing methods to be marked.</p> <p>:type node: ast.ClassDef</p> <p>:return: None</p> <p>:rtype: None</p> Snippet Python<pre><code>def wrapped_mark_methods_for_testing(node: ast.ClassDef) -&gt; None:\n    \"\"\"\n    Just encapsulates `_mark_methods` function, just for unittesting.\n\n    :param node: The class definition node containing methods to be marked.\n    :type node: ast.ClassDef\n    :return: None\n    :rtype: None\n    \"\"\"\n    return _mark_methods(node)\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#def-wrapped_handle_std_nodes_for_testing","title":"<code>def wrapped_handle_std_nodes_for_testing</code>","text":"<p>Type: <code>function</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>node: ast.AST</code></p> <p>Kwargs: <code>None</code></p> <p>Return Type: <code>list[StandardReturn]</code></p> Docstring <p>Just encapsulates <code>_handle_std_nodes</code> function, just for unittesting.</p> <p>:param node: The class definition node containing methods to be marked.</p> <p>:type node: ast.AST</p> <p>:return: An object containing information associated with the node.</p> <p>:rtype: list[StandardReturn]</p> Snippet Python<pre><code>def wrapped_handle_std_nodes_for_testing(node: ast.AST) -&gt; list[StandardReturn]:\n    \"\"\"\n    Just encapsulates `_handle_std_nodes` function, just for unittesting.\n\n    :param node: The class definition node containing methods to be marked.\n    :type node: ast.AST\n    :return: An object containing information associated with the node.\n    :rtype: list[StandardReturn]\n    \"\"\"\n    return _handle_std_nodes(node)\n</code></pre>"},{"location":"Codebase/mosheh/handlers/python.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"Codebase/mosheh/types/__init__.py/","title":"File: <code>__init__.py</code>","text":"<p>Role:  Python Source Code</p> <p>Path: <code>mosheh.types</code></p> <p>No file docstring provided.</p>"},{"location":"Codebase/mosheh/types/__init__.py/#imports","title":"Imports","text":"<p>NO IMPORT DEFINED HERE</p>"},{"location":"Codebase/mosheh/types/__init__.py/#consts","title":"Consts","text":"<p>NO CONSTANT DEFINED HERE</p>"},{"location":"Codebase/mosheh/types/__init__.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"Codebase/mosheh/types/__init__.py/#functions","title":"Functions","text":"<p>NO FUNCTION DEFINED HERE</p>"},{"location":"Codebase/mosheh/types/__init__.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"Codebase/mosheh/types/basic.py/","title":"File: <code>basic.py</code>","text":"<p>Role:  Python Source Code</p> <p>Path: <code>mosheh.types</code></p> <p>Not a secret about these definitions, it's as simple as possible.</p> <p>The idea here is not to create custom complex types, but to serve as hints about what shoud be here or there; most of the type aliases are just commom strings, but their names helps when reading a long, deeper code, showing if that string should be an argument or a code snippet.</p> <p>The use of <code>typing.Annotated</code> does not change the alias itself, but helps with a description about the type.</p>"},{"location":"Codebase/mosheh/types/basic.py/#imports","title":"Imports","text":""},{"location":"Codebase/mosheh/types/basic.py/#import-annotated","title":"<code>import Annotated</code>","text":"<p>Path: <code>typing</code></p> <p>Category: native</p> Snippet Python<pre><code>from typing import Annotated\n</code></pre>"},{"location":"Codebase/mosheh/types/basic.py/#import-filerole","title":"<code>import FileRole</code>","text":"<p>Path: <code>mosheh.types.enums</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.enums import FileRole\n</code></pre>"},{"location":"Codebase/mosheh/types/basic.py/#import-functiontype","title":"<code>import FunctionType</code>","text":"<p>Path: <code>mosheh.types.enums</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.enums import FunctionType\n</code></pre>"},{"location":"Codebase/mosheh/types/basic.py/#import-importtype","title":"<code>import ImportType</code>","text":"<p>Path: <code>mosheh.types.enums</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.enums import ImportType\n</code></pre>"},{"location":"Codebase/mosheh/types/basic.py/#import-statement","title":"<code>import Statement</code>","text":"<p>Path: <code>mosheh.types.enums</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.enums import Statement\n</code></pre>"},{"location":"Codebase/mosheh/types/basic.py/#consts","title":"Consts","text":"<p>NO CONSTANT DEFINED HERE</p>"},{"location":"Codebase/mosheh/types/basic.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"Codebase/mosheh/types/basic.py/#functions","title":"Functions","text":"<p>NO FUNCTION DEFINED HERE</p>"},{"location":"Codebase/mosheh/types/basic.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"Codebase/mosheh/types/contracts.py/","title":"File: <code>contracts.py</code>","text":"<p>Role:  Python Source Code</p> <p>Path: <code>mosheh.types</code></p> <p>Thinking on security during runtime execution, specially for typing annotations and standard contracts - since Python has not type checking it's strength - here are defined the \"Contracts\" for each statement tracked.</p> <p>These dataclasses are used to ensure the correct value type and attribution, so every time each of them appears, they are going to have the desired and expected behavior.</p>"},{"location":"Codebase/mosheh/types/contracts.py/#imports","title":"Imports","text":""},{"location":"Codebase/mosheh/types/contracts.py/#import-namedtuple","title":"<code>import NamedTuple</code>","text":"<p>Path: <code>typing</code></p> <p>Category: native</p> Snippet Python<pre><code>from typing import NamedTuple\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#import-annotation","title":"<code>import Annotation</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Annotation\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#import-args","title":"<code>import Args</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Args\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#import-assertionmessage","title":"<code>import AssertionMessage</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import AssertionMessage\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#import-assertiontest","title":"<code>import AssertionTest</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import AssertionTest\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#import-codesnippet","title":"<code>import CodeSnippet</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import CodeSnippet\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#import-decorator","title":"<code>import Decorator</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Decorator\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#import-docstring","title":"<code>import Docstring</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Docstring\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#import-importedidentifier","title":"<code>import ImportedIdentifier</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import ImportedIdentifier\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#import-inheritance","title":"<code>import Inheritance</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Inheritance\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#import-kwargs","title":"<code>import Kwargs</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Kwargs\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#import-modulename","title":"<code>import ModuleName</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import ModuleName\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#import-modulepath","title":"<code>import ModulePath</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import ModulePath\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#import-token","title":"<code>import Token</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Token\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#import-value","title":"<code>import Value</code>","text":"<p>Path: <code>mosheh.types.basic</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.basic import Value\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#import-functiontype","title":"<code>import FunctionType</code>","text":"<p>Path: <code>mosheh.types.enums</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.enums import FunctionType\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#import-importtype","title":"<code>import ImportType</code>","text":"<p>Path: <code>mosheh.types.enums</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.enums import ImportType\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#import-statement","title":"<code>import Statement</code>","text":"<p>Path: <code>mosheh.types.enums</code></p> <p>Category: trdparty</p> Snippet Python<pre><code>from mosheh.types.enums import Statement\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#consts","title":"Consts","text":"<p>NO CONSTANT DEFINED HERE</p>"},{"location":"Codebase/mosheh/types/contracts.py/#classes","title":"Classes","text":""},{"location":"Codebase/mosheh/types/contracts.py/#class-importcontract","title":"<code>class ImportContract</code>","text":"<p>Parents: <code>NamedTuple</code></p> <p>Decorators: <code>None</code></p> <p>Kwargs: <code>None</code></p> Docstring <p><code>ast.Import</code> contract for typing and declaration security.</p> Snippet Python<pre><code>class ImportContract(NamedTuple):\n    \"\"\"`ast.Import` contract for typing and declaration security.\"\"\"\n    statement: Statement\n    name: ModuleName\n    path: None\n    category: ImportType\n    code: CodeSnippet\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#class-importfromcontract","title":"<code>class ImportFromContract</code>","text":"<p>Parents: <code>NamedTuple</code></p> <p>Decorators: <code>None</code></p> <p>Kwargs: <code>None</code></p> Docstring <p><code>ast.ImportFrom</code> contract for typing and declaration security.</p> Snippet Python<pre><code>class ImportFromContract(NamedTuple):\n    \"\"\"`ast.ImportFrom` contract for typing and declaration security.\"\"\"\n    statement: Statement\n    name: ImportedIdentifier\n    path: ModulePath | None\n    category: ImportType\n    code: CodeSnippet\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#class-assigncontract","title":"<code>class AssignContract</code>","text":"<p>Parents: <code>NamedTuple</code></p> <p>Decorators: <code>None</code></p> <p>Kwargs: <code>None</code></p> Docstring <p><code>ast.Assign</code> contract for typing and declaration security.</p> Snippet Python<pre><code>class AssignContract(NamedTuple):\n    \"\"\"`ast.Assign` contract for typing and declaration security.\"\"\"\n    statement: Statement\n    tokens: list[Token]\n    value: Value\n    code: CodeSnippet\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#class-annassigncontract","title":"<code>class AnnAssignContract</code>","text":"<p>Parents: <code>NamedTuple</code></p> <p>Decorators: <code>None</code></p> <p>Kwargs: <code>None</code></p> Docstring <p><code>ast.AnnAssign</code> contract for typing and declaration security.</p> Snippet Python<pre><code>class AnnAssignContract(NamedTuple):\n    \"\"\"`ast.AnnAssign` contract for typing and declaration security.\"\"\"\n    statement: Statement\n    name: Token\n    annot: Annotation\n    value: Value\n    code: CodeSnippet\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#class-functiondefcontract","title":"<code>class FunctionDefContract</code>","text":"<p>Parents: <code>NamedTuple</code></p> <p>Decorators: <code>None</code></p> <p>Kwargs: <code>None</code></p> Docstring <p><code>ast.FunctionDef</code> contract for typing and declaration security.</p> Snippet Python<pre><code>class FunctionDefContract(NamedTuple):\n    \"\"\"`ast.FunctionDef` contract for typing and declaration security.\"\"\"\n    statement: Statement\n    name: Token\n    category: FunctionType\n    docstring: Docstring | None\n    decorators: list[Decorator]\n    rtype: Annotation | None\n    args: Args\n    kwargs: Kwargs\n    code: CodeSnippet\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#class-asyncfunctiondefcontract","title":"<code>class AsyncFunctionDefContract</code>","text":"<p>Parents: <code>NamedTuple</code></p> <p>Decorators: <code>None</code></p> <p>Kwargs: <code>None</code></p> Docstring <p><code>ast.AsyncFunctionDef</code> contract for typing and declaration security.</p> Snippet Python<pre><code>class AsyncFunctionDefContract(NamedTuple):\n    \"\"\"`ast.AsyncFunctionDef` contract for typing and declaration security.\"\"\"\n    statement: Statement\n    name: Token\n    category: FunctionType\n    docstring: Docstring | None\n    decorators: list[Decorator]\n    rtype: Annotation | None\n    args: Args\n    kwargs: Kwargs\n    code: CodeSnippet\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#class-classdefcontract","title":"<code>class ClassDefContract</code>","text":"<p>Parents: <code>NamedTuple</code></p> <p>Decorators: <code>None</code></p> <p>Kwargs: <code>None</code></p> Docstring <p><code>ast.ClassDef</code> contract for typing and declaration security.</p> Snippet Python<pre><code>class ClassDefContract(NamedTuple):\n    \"\"\"`ast.ClassDef` contract for typing and declaration security.\"\"\"\n    statement: Statement\n    name: Token\n    docstring: Docstring | None\n    inheritance: list[Inheritance]\n    decorators: list[Decorator]\n    kwargs: Kwargs\n    code: CodeSnippet\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#class-assertcontract","title":"<code>class AssertContract</code>","text":"<p>Parents: <code>NamedTuple</code></p> <p>Decorators: <code>None</code></p> <p>Kwargs: <code>None</code></p> Docstring <p><code>ast.Assert</code> contract for typing and declaration security.</p> Snippet Python<pre><code>class AssertContract(NamedTuple):\n    \"\"\"`ast.Assert` contract for typing and declaration security.\"\"\"\n    statement: Statement\n    test: AssertionTest\n    msg: AssertionMessage | None\n    code: CodeSnippet\n</code></pre>"},{"location":"Codebase/mosheh/types/contracts.py/#functions","title":"Functions","text":"<p>NO FUNCTION DEFINED HERE</p>"},{"location":"Codebase/mosheh/types/contracts.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"Codebase/mosheh/types/enums.py/","title":"File: <code>enums.py</code>","text":"<p>Role:  Python Source Code</p> <p>Path: <code>mosheh.types</code></p> <p>As a professional alternative to dealing with options (e.g. to choose between roles), this file provides standard interfaces for the entire operation of the project.</p> <p>The classes here declared (using any enum type - Enum, StrEnum, IntEnum, ...) are enums with a really useful function: to standardize the possible types of their own types (for example, a function strictly assumes only 4 different types, and exactly one of them).</p>"},{"location":"Codebase/mosheh/types/enums.py/#imports","title":"Imports","text":""},{"location":"Codebase/mosheh/types/enums.py/#import-strenum","title":"<code>import StrEnum</code>","text":"<p>Path: <code>enum</code></p> <p>Category: native</p> Snippet Python<pre><code>from enum import StrEnum\n</code></pre>"},{"location":"Codebase/mosheh/types/enums.py/#import-auto","title":"<code>import auto</code>","text":"<p>Path: <code>enum</code></p> <p>Category: native</p> Snippet Python<pre><code>from enum import auto\n</code></pre>"},{"location":"Codebase/mosheh/types/enums.py/#consts","title":"Consts","text":"<p>NO CONSTANT DEFINED HERE</p>"},{"location":"Codebase/mosheh/types/enums.py/#classes","title":"Classes","text":""},{"location":"Codebase/mosheh/types/enums.py/#class-statement","title":"<code>class Statement</code>","text":"<p>Parents: <code>StrEnum</code></p> <p>Decorators: <code>None</code></p> <p>Kwargs: <code>None</code></p> Docstring <p>Enum-like class to enumerate in-code the dealed statements.</p> Snippet Python<pre><code>class Statement(StrEnum):\n    \"\"\"Enum-like class to enumerate in-code the dealed statements.\"\"\"\n    Import = auto()\n    ImportFrom = auto()\n    Assign = auto()\n    AnnAssign = auto()\n    ClassDef = auto()\n    FunctionDef = auto()\n    AsyncFunctionDef = auto()\n    Assert = auto()\n</code></pre>"},{"location":"Codebase/mosheh/types/enums.py/#class-importtype","title":"<code>class ImportType</code>","text":"<p>Parents: <code>StrEnum</code></p> <p>Decorators: <code>None</code></p> <p>Kwargs: <code>None</code></p> Docstring <p>Enum-like class to enumerate in-code the import types.</p> Snippet Python<pre><code>class ImportType(StrEnum):\n    \"\"\"Enum-like class to enumerate in-code the import types.\"\"\"\n    Native = auto()\n    TrdParty = auto()\n    Local = auto()\n</code></pre>"},{"location":"Codebase/mosheh/types/enums.py/#class-functiontype","title":"<code>class FunctionType</code>","text":"<p>Parents: <code>StrEnum</code></p> <p>Decorators: <code>None</code></p> <p>Kwargs: <code>None</code></p> Docstring <p>Enum-like class to enumerate in-code the function types.</p> Snippet Python<pre><code>class FunctionType(StrEnum):\n    \"\"\"Enum-like class to enumerate in-code the function types.\"\"\"\n    Function = auto()\n    Method = auto()\n    Generator = auto()\n    Coroutine = auto()\n</code></pre>"},{"location":"Codebase/mosheh/types/enums.py/#class-filerole","title":"<code>class FileRole</code>","text":"<p>Parents: <code>StrEnum</code></p> <p>Decorators: <code>None</code></p> <p>Kwargs: <code>None</code></p> Docstring <p>Enum-like class to enumerate in-code the files investigated.</p> Snippet Python<pre><code>class FileRole(StrEnum):\n    \"\"\"Enum-like class to enumerate in-code the files investigated.\"\"\"\n    PythonSourceCode = ':material-language-python: Python Source Code'\n    PythonStubFile = ':material-language-python: Python Stub File'\n</code></pre>"},{"location":"Codebase/mosheh/types/enums.py/#functions","title":"Functions","text":"<p>NO FUNCTION DEFINED HERE</p>"},{"location":"Codebase/mosheh/types/enums.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"Codebase/mosheh/types/jsoncfg.py/","title":"File: <code>jsoncfg.py</code>","text":"<p>Role:  Python Source Code</p> <p>Path: <code>mosheh.types</code></p> <p>To ensure the correct type annotation of the default config file <code>mosheh.json</code> this file invokes the <code>typing.TypedDict</code> powers for leading this mission.</p> <p>The config JSON itself is divided at 2 parts: Documentation and IO:</p> <ul> <li>Documentation: handles the project's data and final documentation configuration</li> <li>IO: handles the input and output infos, such as output path and codebase root</li> </ul> <p>The idea here is to use TypedDict as a typing alias plus contract - kinda.</p>"},{"location":"Codebase/mosheh/types/jsoncfg.py/#imports","title":"Imports","text":""},{"location":"Codebase/mosheh/types/jsoncfg.py/#import-typeddict","title":"<code>import TypedDict</code>","text":"<p>Path: <code>typing</code></p> <p>Category: native</p> Snippet Python<pre><code>from typing import TypedDict\n</code></pre>"},{"location":"Codebase/mosheh/types/jsoncfg.py/#consts","title":"Consts","text":"<p>NO CONSTANT DEFINED HERE</p>"},{"location":"Codebase/mosheh/types/jsoncfg.py/#classes","title":"Classes","text":""},{"location":"Codebase/mosheh/types/jsoncfg.py/#class-documentationjson","title":"<code>class DocumentationJSON</code>","text":"<p>Parents: <code>TypedDict</code></p> <p>Decorators: <code>None</code></p> <p>Kwargs: <code>None</code></p> Docstring <p>Typed-Dict class to ensure right typing for config file's doc section.</p> Snippet Python<pre><code>class DocumentationJSON(TypedDict):\n    \"\"\"Typed-Dict class to ensure right typing for config file's doc section.\"\"\"\n    projectName: str\n    repoName: str\n    repoUrl: str\n    editUri: str\n    siteUrl: str\n    logoPath: str | None\n    readmePath: str | None\n    codebaseNavPath: str\n</code></pre>"},{"location":"Codebase/mosheh/types/jsoncfg.py/#class-iojson","title":"<code>class IOJSON</code>","text":"<p>Parents: <code>TypedDict</code></p> <p>Decorators: <code>None</code></p> <p>Kwargs: <code>None</code></p> Docstring <p>Typed-Dict class to ensure right typing for config file's IO section.</p> Snippet Python<pre><code>class IOJSON(TypedDict):\n    \"\"\"Typed-Dict class to ensure right typing for config file's IO section.\"\"\"\n    rootDir: str\n    outputDir: str\n</code></pre>"},{"location":"Codebase/mosheh/types/jsoncfg.py/#class-defaultjson","title":"<code>class DefaultJSON</code>","text":"<p>Parents: <code>TypedDict</code></p> <p>Decorators: <code>None</code></p> <p>Kwargs: <code>None</code></p> Docstring <p>Typed-Dict class to ensure right typing for config file itself.</p> Snippet Python<pre><code>class DefaultJSON(TypedDict):\n    \"\"\"Typed-Dict class to ensure right typing for config file itself.\"\"\"\n    documentation: DocumentationJSON\n    io: IOJSON\n</code></pre>"},{"location":"Codebase/mosheh/types/jsoncfg.py/#functions","title":"Functions","text":"<p>NO FUNCTION DEFINED HERE</p>"},{"location":"Codebase/mosheh/types/jsoncfg.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"guidelines/","title":"Guidelines","text":"<p>Before thinking about contributing to the project, it's highly recommended to read the guidelines following this page. They define the way everybody should do the stuff, from being polite to not use camelCase on the codebase. The following documents are:</p> <ol> <li>Code of Conduct: defines expected behavior for contributors, promotes a welcoming and inclusive community, and outlines procedures for reporting unacceptable behavior. It helps maintain respectful collaboration and sets standards for communication and interaction.</li> <li>Coding Style: defines the coding conventions and best practices contributors should follow in a project. It covers aspects like naming conventions, indentation, file structure, and formatting rules to ensure code consistency, readability, and maintainability across the codebase.</li> <li>Contributing: provides guidelines for contributing to the project. It typically includes instructions for reporting issues, submitting pull requests, coding standards, and any required tools or setup. The goal is to help contributors understand how to effectively participate in the project's development.</li> <li>To Do: lists planned features, improvements, bug fixes, or tasks that need to be completed in a project. It helps developers track what\u2019s pending or upcoming and can guide contributors on where help is needed.</li> <li>Support: provides information on how users and contributors can get help with the project. It typically includes links to documentation, forums, issue trackers, chat channels, or contact methods for reporting problems or asking questions.</li> </ol>"},{"location":"guidelines/code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"guidelines/code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"guidelines/code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"guidelines/code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"guidelines/code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"guidelines/code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at lucasgoncsilva04@gmail.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"guidelines/code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"guidelines/code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"guidelines/code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"guidelines/code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"guidelines/code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"guidelines/code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct/.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq/. Translations are available at https://www.contributor-covenant.org/translations/.</p>"},{"location":"guidelines/code_of_conduct/#attribution_1","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"guidelines/coding_style/","title":"Coding Style","text":"<p>In Mosheh, consistency is essential. This guide outlines the Python conventions we follow: PEP-aligned, type-safe, readable, and testable. Clean code comes first.</p>"},{"location":"guidelines/coding_style/#general-principles","title":"General Principles","text":"<ul> <li>Adhere to PEP\u00a08 and PEP\u00a0484/561 for typing.</li> <li>Code must explain itself. Comments are allowed only when clarity can\u2019t be improved otherwise.</li> <li>Always follow the existing style of the file you modify\u2014even if it slightly diverges from standards.</li> <li>Prefer explicit, readable patterns over clever but obscure code.</li> </ul>"},{"location":"guidelines/coding_style/#formatting-linting","title":"Formatting &amp; Linting","text":"<p>We use Ruff and mypy to enforce formatting, lint rules, and type safety.</p> <p>Run before committing:</p> Bash<pre><code>uv run task lint\n</code></pre> <p>All reported issues must be resolved before merging.</p>"},{"location":"guidelines/coding_style/#ruff-configuration-highlights","title":"Ru\ufb00 Configuration Highlights","text":"<ul> <li>Single quotes by default</li> <li>Line length: 88 characters</li> <li>2 blank lines after import block</li> <li>Import ordering: std -&gt; third-party -&gt; local</li> <li>Ruff doesn\u2019t enforce PascalCase for classes; reviewers may request adjustments.</li> </ul>"},{"location":"guidelines/coding_style/#naming-conventions","title":"Naming Conventions","text":"Entity Style Example Simple Variables snake_case <code>simple_timeout: [type] = ...</code> Constants UPPER_SNAKE_CASE <code>DEFAULT_TIMEOUT: [type] = ...</code> Functions/Methods snake_case <code>def render_docs()</code> Classes PascalCase <code>class DocumentBuilder</code> Private Members _leading_underscore <code>def _internal_method()</code> Type Aliases PascalCase <code>type FilePath = str</code>"},{"location":"guidelines/coding_style/#type-annotations","title":"Type Annotations","text":"<ul> <li>Variables, functions and methods, as all as possible, must have type annotations.</li> <li>Use <code>mypy</code> with <code>strict = true</code>; fix all type issues.</li> <li>Avoid <code>Any</code> unless explicitly justified.</li> <li>Prefer clear naming or comments over complex casts.</li> </ul>"},{"location":"guidelines/coding_style/#private-members","title":"Private Members","text":"<ul> <li>Prefix any private function/method/variable with a single underscore (<code>_</code>).</li> <li>Private elements must not be used outside their intended scope.</li> <li>If you need broader access, problably you do not need it; make it public in a proper way and add a proper docstrings (or just encapsulate the code for testing, if the case, following the same logic of the existing ones).</li> </ul>"},{"location":"guidelines/coding_style/#comments-docstrings","title":"Comments &amp; Docstrings","text":"<p>Always include a module-level docstring at the top of every <code>.py</code> file.</p> <p>Example from <code>constants.py</code>:</p> Python<pre><code>\"\"\"\nThis module defines constants and templates used throughout the project.\n\nIt aims to standardize project-wide values, ensure consistency, and streamline the\ndevelopment and documentation process.\n\n...\n\"\"\"\n</code></pre>"},{"location":"guidelines/coding_style/#functionmethod-docstrings","title":"Function/Method Docstrings","text":"<p>Use the following style\u2014with a one-line summary, blank line, details, and Sphinx-style <code>:param:</code>/<code>:type:</code>/<code>:return:</code>/<code>:rtype:</code> sections:</p> Python<pre><code>def set_logging_config(v: int = 3) -&gt; None:\n    \"\"\"\n    Configures the logging level for the application based on the provided verbosity.\n\n    Logging is handled using `RichHandler` for enhanced terminal output. The verbosity\n    level `v` controls the logging granularity for the `mosheh` logger, and optionally\n    for the `mkdocs` logger in debug mode.\n\n    :param v: Verbosity level, from 0 (critical) to 4 (debug). Defaults to 3 (info).\n        - 0: Critical\n        - 1: Error\n        - 2: Warning\n        - 3: Info (default)\n        - 4: Debug\n    :type v: int\n    :return: None\n    :rtype: None\n    \"\"\"\n\n    ...\n</code></pre> <ul> <li>The first line is a summary.</li> <li>Leave a blank line, then provide details or notes.</li> <li>Use <code>:param:</code>, <code>:type:</code>, <code>:return:</code>, <code>:rtype:</code> \u2014 do not include <code>:raises:</code> unless warranted.</li> <li>Avoid redundant comments that restate obvious code.</li> </ul>"},{"location":"guidelines/coding_style/#testing","title":"Testing","text":"<ul> <li>Code changes must include or update pytest tests (in <code>tests/unittest/</code>).</li> <li>Use descriptive test names and avoid relying on docstrings alone.</li> <li>Run both unit and documentation CLI tests:</li> </ul> Bash<pre><code>uv run task test\n</code></pre>"},{"location":"guidelines/coding_style/#pre-merge-checklist","title":"Pre-Merge Checklist","text":"<p>Before your PR, ensure:</p> <ul> <li> Style and naming follow conventions</li> <li> <code>uv run task lint</code> yields zero issues (runs 2x if needed)</li> <li> <code>uv run task test</code> passes</li> <li> All files start with meaningful module docstrings</li> <li> No debug prints or commented-out code remain</li> <li> Docstrings accurately describe each public API</li> </ul>"},{"location":"guidelines/coding_style/#when-in-doubt","title":"When in Doubt","text":"<ul> <li>Match the style of existing code.</li> <li>Ask in GitHub if unsure about introducing new patterns.</li> <li>Clarity beats cleverness\u2014always.</li> </ul>"},{"location":"guidelines/contributing/","title":"Contributing Guidelines","text":"<p>Pull requests, bug reports, and all other forms of contribution are welcomed and highly encouraged!</p> <p>This guide serves to set clear expectations for everyone involved with the project so that we can improve it together while also creating a welcoming space for everyone to participate. Following these guidelines will help ensure a positive experience for contributors and maintainers.</p>"},{"location":"guidelines/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please review our Code of Conduct. It is in effect at all times. We expect it to be honored by everyone who contributes to this project. Acting like an asshole will not be tolerated.</p>"},{"location":"guidelines/contributing/#asking-questions","title":"Asking Questions","text":"<p>See our Support Guide. In short, GitHub issues are not the appropriate place to debug your specific project, but should be reserved for filing bugs and feature requests.</p>"},{"location":"guidelines/contributing/#opening-an-issue","title":"Opening an Issue","text":"<p>Before creating an issue, check if you are using the latest version of the project. If you are not up-to-date, see if updating fixes your issue first.</p>"},{"location":"guidelines/contributing/#reporting-security-issues","title":"Reporting Security Issues","text":"<p>Review our Security Policy. Do not file a public issue for security vulnerabilities.</p>"},{"location":"guidelines/contributing/#bug-reports-and-other-issues","title":"Bug Reports and Other Issues","text":"<p>A great way to contribute to the project is to send a detailed issue when you encounter a problem. We always appreciate a well-written, thorough bug report.</p> <p>In short, since you are most likely a developer, provide a ticket that you would like to receive.</p> <ul> <li> <p>Review the documentation and Support Guide before opening a new issue.</p> </li> <li> <p>Do not open a duplicate issue! Search through existing issues to see if your issue has previously been reported. If your issue exists, comment with any additional information you have. You may simply note \"I have this problem too\", which helps prioritize the most common problems and requests.</p> </li> <li> <p>Prefer using reactions, not comments, if you simply want to \"+1\" an existing issue.</p> </li> <li> <p>Fully complete the provided issue template. The bug report template requests all the information we need to quickly and efficiently address your issue. Be clear, concise, and descriptive. Provide as much information as you can, including steps to reproduce, stack traces, compiler errors, library versions, OS versions, and screenshots (if applicable).</p> </li> <li> <p>Use GitHub-flavored Markdown. Especially put code blocks and console outputs in backticks (```). This improves readability.</p> </li> </ul>"},{"location":"guidelines/contributing/#feature-requests","title":"Feature Requests","text":"<p>Feature requests are welcome! While we will consider all requests, we cannot guarantee your request will be accepted. We want to avoid feature creep. Your idea may be great, but also out-of-scope for the project. If accepted, we cannot make any commitments regarding the timeline for implementation and release. However, you are welcome to submit a pull request or create an issue to help!</p> <ul> <li> <p>Do not open a duplicate feature request. Search for existing feature requests first. If you find your feature (or one very similar) previously requested, comment on that issue.</p> </li> <li> <p>Fully complete the provided issue template. The feature request template asks for all necessary information for us to begin a productive conversation.</p> </li> <li> <p>Be precise about the proposed outcome of the feature and how it relates to existing features. Include implementation details if possible.</p> </li> </ul>"},{"location":"guidelines/contributing/#triaging-issues","title":"Triaging Issues","text":"<p>You can triage issues which may include reproducing bug reports or asking for additional information, such as version numbers or reproduction instructions. Any help you can provide to quickly resolve an issue is very much appreciated!</p>"},{"location":"guidelines/contributing/#submitting-pull-requests","title":"Submitting Pull Requests","text":"<p>We love pull requests! Before forking the repo and creating a pull request for non-trivial changes, it is usually best to first open an issue to discuss the changes, or discuss your intended approach for solving the problem in the comments for an existing issue.</p> <p>For some contributions, after your first pull request is accepted and merged, you will be invited to the project and given push access.</p> <p>Note: All contributions will be licensed under the project's license.</p> <ul> <li> <p>Smaller is better. Submit one pull request per bug fix or feature. A pull request should contain isolated changes pertaining to a single bug fix or feature implementation. Do not refactor or reformat code that is unrelated to your change. It is better to submit many small pull requests rather than a single large one. Enormous pull requests will take enormous amounts of time to review, or may be rejected altogether.</p> </li> <li> <p>Coordinate bigger changes. For large and non-trivial changes, open an issue to discuss a strategy with the maintainers. Otherwise, you risk doing a lot of work for nothing!</p> </li> <li> <p>Prioritize understanding over cleverness. Write code clearly and concisely. Remember that source code usually gets written once and read often. Ensure the code is clear to the reader. The purpose and logic should be obvious to a reasonably skilled developer, otherwise you should add a comment that explains it.</p> </li> <li> <p>Follow existing coding style and conventions. Keep your code consistent with the style, formatting, and conventions in the rest of the code base. When possible, these will be enforced with a linter. Consistency makes it easier to review and modify in the future.</p> </li> <li> <p>Include test coverage. Add unit tests or UI tests when possible. Follow existing patterns for implementing tests.</p> </li> <li> <p>Update the example project if one exists to exercise any new functionality you have added.</p> </li> <li> <p>Add documentation. Document your changes with code doc comments or in existing guides.</p> </li> <li> <p>Update the CHANGELOG for all enhancements and bug fixes. Include the corresponding issue number if one exists, and your GitHub username. (example: \"- Fixed crash in profile view. #123 @jessesquires\")</p> </li> <li> <p>Use the repo's correct branch. Branch from <code>main</code> and submit your pull request to <code>review</code>:</p> </li> </ul>  Do    Do NOT <pre><code>%%{init: { 'logLevel': 'debug', 'themeVariables': {\n            'git0': '#0077ff77',\n            'git1': '#00770077',\n            'git2': '#ffaa0077'\n    } } }%%\n\ngitGraph\n    commit id: \" \" tag: \"v1.0.0\"\n    branch stg\n    branch review\n    branch your_dev\n    checkout your_dev\n    commit id: \"[feat] XYZ\"\n    commit id: \"[fix] ABC\"\n    checkout review\n    merge your_dev tag: \"Lorem Ipsum\"\n    checkout stg\n    merge review tag: \"v1.1.0-stg\"\n    checkout main\n    merge stg tag: \"v1.1.0\"</code></pre> <pre><code>%%{init: { 'logLevel': 'debug', 'themeVariables': {\n            'git0': '#0077ff77',\n            'git1': '#00770077',\n            'git2': '#ffaa0077'\n    } } }%%\n\ngitGraph\n    commit id: \" \" tag: \"v1.0.0\"\n    branch stg\n    branch review\n    branch your_dev\n    checkout your_dev\n    commit id: \"[feat] XYZ\"\n    commit id: \"[fix] ABC\"\n    checkout main\n    merge your_dev tag: \"Lorem Ipsum\"</code></pre> <pre><code>%%{init: { 'logLevel': 'debug', 'themeVariables': {\n            'git0': '#0077ff77',\n            'git1': '#00770077',\n            'git2': '#ffaa0077'\n    } } }%%\n\ngitGraph\n    commit id: \" \" tag: \"v1.0.0\"\n    branch stg\n    branch review\n    branch your_dev\n    checkout your_dev\n    commit id: \"[feat] XYZ\"\n    commit id: \"[fix] ABC\"\n    checkout stg\n    merge your_dev tag: \"Lorem Ipsum\"</code></pre> <p>Pull Requests MUST BE BRANCHED FROM <code>main</code> AND SUBMITTED TO <code>review</code></p> <ul> <li> <p>Resolve any merge conflicts that occur.</p> </li> <li> <p>Promptly address any CI failures. If your pull request fails to build or pass tests, please push another commit to fix it.</p> </li> <li> <p>When writing comments, use properly constructed sentences, including punctuation.</p> </li> <li> <p>Use spaces, not tabs.</p> </li> </ul>"},{"location":"guidelines/contributing/#writing-commit-messages","title":"Writing Commit Messages","text":"<p>Please write a great commit message. Do not be afraid of describing what your commit changes; remember that communication is key. When committing small or simple changes, messaging your commit with a single line is completely fine, but when dealing with bigger or complex changes... ow God please spend some time on writing a longer message, please! In all cases, follow the rules below:</p> <ol> <li>Separate subject from body with a blank line</li> <li>Limit the subject line to 50 characters</li> <li>Capitalize the subject line</li> <li>Do not end the subject line with a period</li> <li>Use the imperative mood in the subject line (example: \"Fix networking issue\")</li> <li>Wrap the body at 72 characters</li> <li>Use the body to explain why, not what and how (the code shows that!)</li> <li>Prefix the title with the relevant component name with \"{tag}: \", in lowercase (e.g.: <code>fix: Message</code>, <code>feat: Message</code>)</li> </ol> <p>Suggest list of tags after the demonstration:</p> Text Only<pre><code>[tag]: Short summary of changes in 50 chars or less\n\nAdd a more detailed explanation here, if necessary. Possibly give\nsome background about the issue being fixed, etc. The body of the\ncommit message can be several paragraphs. Further paragraphs come\nafter blank lines and please do proper word-wrap.\n\nWrap it to about 72 characters or so. In some contexts,\nthe first line is treated as the subject of the commit and the\nrest of the text as the body. The blank line separating the summary\nfrom the body is critical (unless you omit the body entirely);\nvarious tools like `log`, `shortlog` and `rebase` can get confused\nif you run the two together.\n\nExplain the problem that this commit is solving. Focus on why you\nare making this change as opposed to how or what. The code explains\nhow or what. Reviewers and your future self can read the patch,\nbut might not understand why a particular solution was implemented.\nAre there side effects or other unintuitive consequences of this\nchange? Here's the place to explain them.\n\n - Bullet points are okay, too\n\n - A hyphen or asterisk should be used for the bullet, preceded\n   by a single space, with blank lines in between\n\nNote the fixed or relevant GitHub issues at the end:\n\nResolves: #123\nSee also: #456, #789\n</code></pre> <p>Scope: There is no table with all possible options, it depends directly on what was commited. The idea is to define in one word where the commit changes the codebase; some possible examples below - already used ones:</p> Tag Description Example <code>feat</code> Addition of new feature. <code>feat: Add recovery password logic</code> <code>fix</code> Bug fixing. <code>fix: Correct button alignment</code> <code>docs</code> Docs updating (README, code examples, etc.). <code>docs: Update doc homepage</code> <code>refactor</code> Makes better code, no bug fixes, no new features. <code>refactor: Simplify validation logic</code> <code>test</code> Test addition or modify. <code>test: Add unit tests for user model</code> <code>build</code> Updates on build stuff. <code>build: Add new plugin for optimization</code> <code>ci</code> Updates on CI/CD config. <code>ci: Update workflows checkout repo</code> <code>perf</code> Performance upgrades. <code>perf: Optimize select_related</code> <code>sec</code> Security improvements. <code>sec: Handle token expiration vulnerability</code> <code>hotfix</code> Urgent... hot... fixes... <code>hotfix: Fix crash on empty input</code> <code>chore</code> Administrative tasks, no impact on product. <code>chore: Add discussion templates</code> <code>config</code> Updates on general configs. <code>config: Update MkDocs dependency version</code>"},{"location":"guidelines/contributing/#code-review","title":"Code Review","text":"<ul> <li> <p>Review the code, not the author. Look for and suggest improvements without disparaging or insulting the author. Provide actionable feedback and explain your reasoning.</p> </li> <li> <p>You are not your code. When your code is critiqued, questioned, or constructively criticized, remember that you are not your code. Do not take code review personally.</p> </li> <li> <p>Always do your best. No one writes bugs on purpose. Do your best, and learn from your mistakes.</p> </li> <li> <p>Kindly note any violations to the guidelines specified in this document.</p> </li> </ul>"},{"location":"guidelines/contributing/#certificate-of-origin","title":"Certificate of Origin","text":"<p>Developer's Certificate of Origin 1.1</p> <p>By making a contribution to this project, I certify that:</p> <ol> <li>The contribution was created in whole or in part by me and I have the right to submit it under the open source license indicated in the file; or</li> <li>The contribution is based upon previous work that, to the best of my knowledge, is covered under an appropriate open source license and I have the right under that license to submit that work with modifications, whether created in whole or in part by me, under the same open source license (unless I am permitted to submit under a different license), as indicated in the file; or</li> <li>The contribution was provided directly to me by some other person who certified (1), (2) or (3) and I have not modified it.</li> <li>I understand and agree that this project and the contribution are public and that a record of the contribution (including all personal information I submit with it, including my sign-off) is maintained indefinitely and may be redistributed consistent with this project or the open source license(s) involved.</li> </ol>"},{"location":"guidelines/contributing/#credits","title":"Credits","text":"<p>Written by @jessesquires, editted to Mosheh by @LucasGoncSilva.</p> <p>Please feel free to adopt this guide in your own projects. Fork it wholesale or remix it for your needs.</p> <p>Many of the ideas and prose for the statements in this document were based on or inspired by work from the following communities:</p> <ul> <li>Alamofire</li> <li>CocoaPods</li> <li>Docker</li> <li>Linux</li> </ul> <p>We commend them for their efforts to facilitate collaboration in their projects.</p>"},{"location":"guidelines/support/","title":"Support and Help","text":"<p>Need help for getting started or using a project? Here's how.</p>"},{"location":"guidelines/support/#how-to-get-help","title":"How to get help","text":"<p>Generally, we do not use GitHub as a support forum. For any usage questions that are not specific to the project itself, please check Stack Overflow or ask some AI instead. By doing so, you are more likely to quickly solve your problem, and you will allow anyone else with the same question to find the answer (going SO's way). This also allows maintainers to focus on improving the project for others.</p> <p>Now, in case of having some issue with the project itself please seek support in the following ways:</p> <ol> <li>Read the project's documentation and other guides to check if you can figure it out on your own. These are located under this URL; everything you may need to know about Mosheh is going to be there.</li> <li>Search for answers and ask questions on Stack Overflow. This is the most appropriate place for debugging issues specific to your use of the project, or figuring out how to use the project in a specific way.</li> <li>As a last resort, you may open an issue on GitHub to ask for help. However, please clearly explain what you are trying to do, and list what you have already attempted to solve the problem. Provide code samples, but do not attach your entire project for someone else to debug.</li> </ol>"},{"location":"guidelines/support/#what-not-to-do","title":"What NOT to do","text":"<p>Please do not do any the following:</p> <ol> <li>Do not reach out to the author or contributor on X (or other social media) by tweeting or sending a direct message.</li> <li>Do not email the author or contributor.</li> <li>Do not open duplicate issues or comment an existing issue with \"+1\"; use emojis instead.</li> </ol> <p>These are not appropriate avenues for seeking help or support with an open-source project. Please follow the guidelines in the previous section. Public questions get public answers, which benefits everyone in the community.</p>"},{"location":"guidelines/support/#customer-support","title":"Customer Support","text":"<p>I do not provide any sort of \"customer support\" for open-source projects individually. However, if you wanna talk about some work to get done visit lucasgonc.vercel.app.</p>"},{"location":"guidelines/todo/","title":"To-Do List","text":""},{"location":"guidelines/todo/#to-be-evaluated","title":"To Be Evaluated","text":"<ul> <li> Use Rust for better processing</li> <li> Process of more files than just Python ones (e.g. <code>.txt</code>, <code>.toml</code>, other langs)</li> <li> Create detail page for classes with docstring and listing class constants and methods</li> <li> Create detail page for functions with docstring and body detail</li> </ul>"},{"location":"guidelines/todo/#to-do","title":"To Do","text":"<ul> <li> Handle <code>.github</code> files such as guidelines (<code>TODO</code>, <code>CONTRIBUTING</code>, ...)</li> <li> Provide an \"exclude\" config for files/dirs to ignore</li> <li> Insert <code>tags</code> for <code>.md</code> based on their names/contexts</li> <li> Get and list all metrics of statements featured</li> </ul>"},{"location":"guidelines/todo/#done","title":"Done","text":"<ul> <li> Migrate dependency system to use uv</li> <li> Process 100% of Python AST's nodes on <code>mosheh.handlers.python</code></li> <li> Check for files docstrings and write below filepath</li> <li> Accept structured file (e.g. <code>mosheh.json</code>) as parameters replacement</li> </ul>"}]}